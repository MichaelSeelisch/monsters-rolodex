(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = function deepFreeze (o) {
  Object.freeze(o);

  var oIsFunction = typeof o === "function";
  var hasOwnProp = Object.prototype.hasOwnProperty;

  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (hasOwnProp.call(o, prop)
    && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true )
    && o[prop] !== null
    && (typeof o[prop] === "object" || typeof o[prop] === "function")
    && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  
  return o;
};

},{}],2:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _isRegexp = require('is-regexp');

var _isRegexp2 = _interopRequireDefault(_isRegexp);

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _SpyUtils = require('./SpyUtils');

var _TestUtils = require('./TestUtils');

/**
 * An Expectation is a wrapper around an assertion that allows it to be written
 * in a more natural style, without the need to remember the order of arguments.
 * This helps prevent you from making mistakes when writing tests.
 */

var Expectation = (function () {
  function Expectation(actual) {
    _classCallCheck(this, Expectation);

    this.actual = actual;

    if (_TestUtils.isFunction(actual)) {
      this.context = null;
      this.args = [];
    }
  }

  Expectation.prototype.toExist = function toExist(message) {
    _assert2['default'](this.actual, message || 'Expected %s to exist', this.actual);

    return this;
  };

  Expectation.prototype.toNotExist = function toNotExist(message) {
    _assert2['default'](!this.actual, message || 'Expected %s to not exist', this.actual);

    return this;
  };

  Expectation.prototype.toBe = function toBe(value, message) {
    _assert2['default'](this.actual === value, message || 'Expected %s to be %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toNotBe = function toNotBe(value, message) {
    _assert2['default'](this.actual !== value, message || 'Expected %s to not be %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toEqual = function toEqual(value, message) {
    try {
      _assert2['default'](_deepEqual2['default'](this.actual, value), message || 'Expected %s to equal %s', this.actual, value);
    } catch (e) {
      // These attributes are consumed by Mocha to produce a diff output.
      e.showDiff = true;
      e.actual = this.actual;
      e.expected = value;
      throw e;
    }

    return this;
  };

  Expectation.prototype.toNotEqual = function toNotEqual(value, message) {
    _assert2['default'](!_deepEqual2['default'](this.actual, value), message || 'Expected %s to not equal %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toThrow = function toThrow(value, message) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).toThrow() must be a function, %s was given', this.actual);

    _assert2['default'](_TestUtils.functionThrows(this.actual, this.context, this.args, value), message || 'Expected %s to throw %s', this.actual, value || 'an error');

    return this;
  };

  Expectation.prototype.toNotThrow = function toNotThrow(value, message) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).toNotThrow() must be a function, %s was given', this.actual);

    _assert2['default'](!_TestUtils.functionThrows(this.actual, this.context, this.args, value), message || 'Expected %s to not throw %s', this.actual, value || 'an error');

    return this;
  };

  Expectation.prototype.toBeA = function toBeA(value, message) {
    _assert2['default'](_TestUtils.isFunction(value) || typeof value === 'string', 'The "value" argument in toBeA(value) must be a function or a string');

    _assert2['default'](_TestUtils.isA(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toNotBeA = function toNotBeA(value, message) {
    _assert2['default'](_TestUtils.isFunction(value) || typeof value === 'string', 'The "value" argument in toNotBeA(value) must be a function or a string');

    _assert2['default'](!_TestUtils.isA(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toMatch = function toMatch(pattern, message) {
    _assert2['default'](typeof this.actual === 'string', 'The "actual" argument in expect(actual).toMatch() must be a string');

    _assert2['default'](_isRegexp2['default'](pattern), 'The "value" argument in toMatch(value) must be a RegExp');

    _assert2['default'](pattern.test(this.actual), message || 'Expected %s to match %s', this.actual, pattern);

    return this;
  };

  Expectation.prototype.toNotMatch = function toNotMatch(pattern, message) {
    _assert2['default'](typeof this.actual === 'string', 'The "actual" argument in expect(actual).toNotMatch() must be a string');

    _assert2['default'](_isRegexp2['default'](pattern), 'The "value" argument in toNotMatch(value) must be a RegExp');

    _assert2['default'](!pattern.test(this.actual), message || 'Expected %s to not match %s', this.actual, pattern);

    return this;
  };

  Expectation.prototype.toBeLessThan = function toBeLessThan(value, message) {
    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThan() must be a number');

    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeLessThan(value) must be a number');

    _assert2['default'](this.actual < value, message || 'Expected %s to be less than %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toBeGreaterThan = function toBeGreaterThan(value, message) {
    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThan() must be a number');

    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeGreaterThan(value) must be a number');

    _assert2['default'](this.actual > value, message || 'Expected %s to be greater than %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toInclude = function toInclude(value, comparator, message) {
    _assert2['default'](_TestUtils.isArray(this.actual) || typeof this.actual === 'string', 'The "actual" argument in expect(actual).toInclude() must be an array or a string');

    if (typeof comparator === 'string') {
      message = comparator;
      comparator = null;
    }

    message = message || 'Expected %s to include %s';

    if (_TestUtils.isArray(this.actual)) {
      _assert2['default'](_TestUtils.arrayContains(this.actual, value, comparator), message, this.actual, value);
    } else {
      _assert2['default'](_TestUtils.stringContains(this.actual, value), message, this.actual, value);
    }

    return this;
  };

  Expectation.prototype.toExclude = function toExclude(value, comparator, message) {
    _assert2['default'](_TestUtils.isArray(this.actual) || typeof this.actual === 'string', 'The "actual" argument in expect(actual).toExclude() must be an array or a string');

    if (typeof comparator === 'string') {
      message = comparator;
      comparator = null;
    }

    message = message || 'Expected %s to exclude %s';

    if (_TestUtils.isArray(this.actual)) {
      _assert2['default'](!_TestUtils.arrayContains(this.actual, value, comparator), message, this.actual, value);
    } else {
      _assert2['default'](!_TestUtils.stringContains(this.actual, value), message, this.actual, value);
    }

    return this;
  };

  Expectation.prototype.toHaveBeenCalled = function toHaveBeenCalled(message) {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toHaveBeenCalled() must be a spy');

    _assert2['default'](spy.calls.length > 0, message || 'spy was not called');

    return this;
  };

  Expectation.prototype.toHaveBeenCalledWith = function toHaveBeenCalledWith() {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toHaveBeenCalledWith() must be a spy');

    var expectedArgs = Array.prototype.slice.call(arguments, 0);

    _assert2['default'](spy.calls.some(function (call) {
      return _deepEqual2['default'](call.arguments, expectedArgs);
    }), 'spy was never called with %s', expectedArgs);

    return this;
  };

  Expectation.prototype.toNotHaveBeenCalled = function toNotHaveBeenCalled(message) {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toNotHaveBeenCalled() must be a spy');

    _assert2['default'](spy.calls.length === 0, message || 'spy was not supposed to be called');

    return this;
  };

  Expectation.prototype.withContext = function withContext(context) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).withContext() must be a function');

    this.context = context;

    return this;
  };

  Expectation.prototype.withArgs = function withArgs() {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).withArgs() must be a function');

    if (arguments.length) this.args = this.args.concat(Array.prototype.slice.call(arguments, 0));

    return this;
  };

  return Expectation;
})();

var aliases = {
  toBeAn: 'toBeA',
  toNotBeAn: 'toNotBeA',
  toBeTruthy: 'toExist',
  toBeFalsy: 'toNotExist',
  toBeFewerThan: 'toBeLessThan',
  toBeMoreThan: 'toBeGreaterThan',
  toContain: 'toInclude',
  toNotContain: 'toExclude'
};

for (var alias in aliases) {
  Expectation.prototype[alias] = Expectation.prototype[aliases[alias]];
}exports['default'] = Expectation;
module.exports = exports['default'];
},{"./SpyUtils":3,"./TestUtils":4,"./assert":5,"deep-equal":8,"is-regexp":11}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.createSpy = createSpy;
exports.spyOn = spyOn;
exports.isSpy = isSpy;
exports.restoreSpies = restoreSpies;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _TestUtils = require('./TestUtils');

function noop() {}

var spies = [];

function createSpy(fn) {
  var restore = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];

  if (fn == null) fn = noop;

  _assert2['default'](_TestUtils.isFunction(fn), 'createSpy needs a function');

  var targetFn = undefined,
      thrownValue = undefined,
      returnValue = undefined;

  var spy = function spy() {
    spy.calls.push({
      context: this,
      arguments: Array.prototype.slice.call(arguments, 0)
    });

    if (targetFn) return targetFn.apply(this, arguments);

    if (thrownValue) throw thrownValue;

    return returnValue;
  };

  spy.calls = [];

  spy.andCall = function (fn) {
    targetFn = fn;
    return spy;
  };

  spy.andCallThrough = function () {
    return spy.andCall(fn);
  };

  spy.andThrow = function (object) {
    thrownValue = object;
    return spy;
  };

  spy.andReturn = function (value) {
    returnValue = value;
    return spy;
  };

  spy.getLastCall = function () {
    return spy.calls[spy.calls.length - 1];
  };

  spy.restore = spy.destroy = restore;

  spy.__isSpy = true;

  spies.push(spy);

  return spy;
}

function spyOn(object, methodName) {
  var original = object[methodName];

  if (!isSpy(original)) {
    _assert2['default'](_TestUtils.isFunction(original), 'Cannot spyOn the %s property; it is not a function', methodName);

    object[methodName] = createSpy(original, function () {
      object[methodName] = original;
    });
  }

  return object[methodName];
}

function isSpy(object) {
  return object && object.__isSpy === true;
}

function restoreSpies() {
  for (var i = spies.length - 1; i >= 0; i--) {
    spies[i].restore();
  }spies = [];
}
},{"./TestUtils":4,"./assert":5}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.functionThrows = functionThrows;
exports.arrayContains = arrayContains;
exports.stringContains = stringContains;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isA = isA;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _isRegexp = require('is-regexp');

var _isRegexp2 = _interopRequireDefault(_isRegexp);

/**
 * Returns true if the given function throws the given value
 * when invoked. The value may be:
 *
 * - undefined, to merely assert there was a throw
 * - a constructor function, for comparing using instanceof
 * - a regular expression, to compare with the error message
 * - a string, to find in the error message
 */

function functionThrows(fn, context, args, value) {
  try {
    fn.apply(context, args);
  } catch (error) {
    if (value == null) return true;

    if (isFunction(value) && error instanceof value) return true;

    var message = error.message || error;

    if (typeof message === 'string') {
      if (_isRegexp2['default'](value) && value.test(error.message)) return true;

      if (typeof value === 'string' && message.indexOf(value) !== -1) return true;
    }
  }

  return false;
}

/**
 * Returns true if the given array contains the value, false
 * otherwise. The comparator function must return false to
 * indicate a non-match.
 */

function arrayContains(array, value, comparator) {
  if (comparator == null) comparator = _deepEqual2['default'];

  return array.some(function (item) {
    return comparator(item, value) !== false;
  });
}

/**
 * Returns true if the given string contains the value, false otherwise.
 */

function stringContains(string, value) {
  return string.indexOf(value) !== -1;
}

/**
 * Returns true if the given object is an array.
 */

function isArray(object) {
  return Array.isArray(object);
}

/**
 * Returns true if the given object is a function.
 */

function isFunction(object) {
  return typeof object === 'function';
}

/**
 * Returns true if the given object is an instanceof value
 * or its typeof is the given value.
 */

function isA(object, value) {
  if (isFunction(value)) return object instanceof value;

  if (value === 'array') return Array.isArray(object);

  return typeof object === value;
}
},{"deep-equal":8,"is-regexp":11}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _objectInspect = require('object-inspect');

var _objectInspect2 = _interopRequireDefault(_objectInspect);

function assert(condition, messageFormat) {
  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    extraArgs[_key - 2] = arguments[_key];
  }

  if (condition) return;

  var index = 0;

  throw new Error(messageFormat.replace(/%s/g, function () {
    return _objectInspect2['default'](extraArgs[index++]);
  }));
}

exports['default'] = assert;
module.exports = exports['default'];
},{"object-inspect":12}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Expectation = require('./Expectation');

var _Expectation2 = _interopRequireDefault(_Expectation);

var Extensions = [];

function extend(extension) {
  if (Extensions.indexOf(extension) === -1) {
    Extensions.push(extension);

    for (var p in extension) {
      if (extension.hasOwnProperty(p)) _Expectation2['default'].prototype[p] = extension[p];
    }
  }
}

exports['default'] = extend;
module.exports = exports['default'];
},{"./Expectation":2}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Expectation = require('./Expectation');

var _Expectation2 = _interopRequireDefault(_Expectation);

var _SpyUtils = require('./SpyUtils');

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _extend = require('./extend');

var _extend2 = _interopRequireDefault(_extend);

function expect(actual) {
  return new _Expectation2['default'](actual);
}

expect.createSpy = _SpyUtils.createSpy;
expect.spyOn = _SpyUtils.spyOn;
expect.isSpy = _SpyUtils.isSpy;
expect.restoreSpies = _SpyUtils.restoreSpies;
expect.assert = _assert2['default'];
expect.extend = _extend2['default'];

exports['default'] = expect;
module.exports = exports['default'];
},{"./Expectation":2,"./SpyUtils":3,"./assert":5,"./extend":6}],8:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":9,"./lib/keys.js":10}],9:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],10:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],11:[function(require,module,exports){
'use strict';
module.exports = function (re) {
	return Object.prototype.toString.call(re) === '[object RegExp]';
};

},{}],12:[function(require,module,exports){
module.exports = function inspect_ (obj, opts, depth, seen) {
    if (!opts) opts = {};
    
    var maxDepth = opts.depth === undefined ? 5 : opts.depth;
    if (depth === undefined) depth = 0;
    if (depth >= maxDepth && maxDepth > 0
    && obj && typeof obj === 'object') {
        return '[Object]';
    }
    
    if (seen === undefined) seen = [];
    else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }
    
    function inspect (value, from) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        return inspect_(value, opts, depth + 1, seen);
    }
    
    if (typeof obj === 'string') {
        return inspectString(obj);
    }
    else if (typeof obj === 'function') {
        var name = nameOf(obj);
        return '[Function' + (name ? ': ' + name : '') + ']';
    }
    else if (obj === null) {
        return 'null';
    }
    else if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;
    }
    else if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '="' + quote(attrs[i].value) + '"';
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) s += '...';
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    else if (isArray(obj)) {
        if (obj.length === 0) return '[]';
        var xs = Array(obj.length);
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    else if (isError(obj)) {
        var parts = [];
        for (var key in obj) {
            if (!has(obj, key)) continue;
            
            if (/[^\w$]/.test(key)) {
                parts.push(inspect(key) + ': ' + inspect(obj[key]));
            }
            else {
                parts.push(key + ': ' + inspect(obj[key]));
            }
        }
        if (parts.length === 0) return '[' + obj + ']';
        return '{ [' + obj + '] ' + parts.join(', ') + ' }';
    }
    else if (typeof obj === 'object' && typeof obj.inspect === 'function') {
        return obj.inspect();
    }
    else if (typeof obj === 'object' && !isDate(obj) && !isRegExp(obj)) {
        var xs = [], keys = [];
        for (var key in obj) {
            if (has(obj, key)) keys.push(key);
        }
        keys.sort();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (/[^\w$]/.test(key)) {
                xs.push(inspect(key) + ': ' + inspect(obj[key], obj));
            }
            else xs.push(key + ': ' + inspect(obj[key], obj));
        }
        if (xs.length === 0) return '{}';
        return '{ ' + xs.join(', ') + ' }';
    }
    else return String(obj);
};

function quote (s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray (obj) { return toStr(obj) === '[object Array]' }
function isDate (obj) { return toStr(obj) === '[object Date]' }
function isRegExp (obj) { return toStr(obj) === '[object RegExp]' }
function isError (obj) { return toStr(obj) === '[object Error]' }
function isSymbol (obj) { return toStr(obj) === '[object Symbol]' }

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has (obj, key) {
    return hasOwn.call(obj, key);
}

function toStr (obj) {
    return Object.prototype.toString.call(obj);
}

function nameOf (f) {
    if (f.name) return f.name;
    var m = f.toString().match(/^function\s*([\w$]+)/);
    if (m) return m[1];
}

function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
}

function isElement (x) {
    if (!x || typeof x !== 'object') return false;
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string'
        && typeof x.getAttribute === 'function'
    ;
}

function inspectString (str) {
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return "'" + s + "'";
    
    function lowbyte (c) {
        var n = c.charCodeAt(0);
        var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
        if (x) return '\\' + x;
        return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
    }
}

},{}],13:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _expect = require('expect');

var _expect2 = _interopRequireDefault(_expect);

var _deepFreezeStrict = require('deep-freeze-strict');

var _deepFreezeStrict2 = _interopRequireDefault(_deepFreezeStrict);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } // Using an ES6 transpiler, like babel

var _React = React;
var Component = _React.Component;
var _Redux = Redux;
var combineReducers = _Redux.combineReducers;
var _ReactRedux = ReactRedux;
var connect = _ReactRedux.connect;
// ES6  via babel: import { connect } from 'react-redux';

var todo = function todo(state, action) {
	switch (action.type) {
		case 'ADD_TODO':
			return {
				id: action.id,
				text: action.text,
				completed: false
			};

		case 'TOGGLE_TODO':
			if (state.id !== action.id) {
				return state;
			}

			return Object.assign({}, state, { 'completed': !state.completed });

		default:
			return state;
	}
};

var todos = function todos() {
	var state = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	var action = arguments[1];

	switch (action.type) {
		case 'ADD_TODO':
			return [].concat(_toConsumableArray(state), [todo(undefined, action)]);

		case 'TOGGLE_TODO':
			return state.map(function (t) {
				return todo(t, action);
			});

		default:
			return state;
	}
};

var visibilityFilter = function visibilityFilter() {
	var state = arguments.length <= 0 || arguments[0] === undefined ? 'SHOW_ALL' : arguments[0];
	var action = arguments[1];

	switch (action.type) {
		case 'SET_VISIBILITY_FILTER':
			return action.filter;

		default:
			return state;
	}
};

var todoApp = combineReducers({
	// Short:
	todos: todos,
	visibilityFilter: visibilityFilter

	// Long:
	/* todos: todos,
 /* visibilityFilter: visibilityFilter
 */
});

var nextTodoId = 0;
var addTodo = function addTodo(text) {
	return {
		type: 'ADD_TODO',
		id: nextTodoId++,
		text: text
	};
};

var toggleTodo = function toggleTodo(id) {
	return {
		type: 'TOGGLE_TODO',
		id: id
	};
};

var Todo = function Todo(_ref) {
	var onClick = _ref.onClick;
	var completed = _ref.completed;
	var text = _ref.text;
	return React.createElement(
		'li',
		{
			onClick: onClick,
			style: {
				textDecoration: completed ? 'line-through' : 'none'
			}
		},
		text
	);
};

var TodoList = function TodoList(_ref2) {
	var todos = _ref2.todos;
	var onTodoClick = _ref2.onTodoClick;
	return React.createElement(
		'ul',
		null,
		todos.map(function (todo) {
			return React.createElement(Todo, _extends({
				key: todo.id
			}, todo, {
				onClick: function onClick() {
					return onTodoClick(todo.id);
				}
			}));
		})
	);
};

var setVisibilityFilter = function setVisibilityFilter(filter) {
	return {
		type: 'SET_VISIBILITY_FILTER',
		filter: filter
	};
};

var Link = function Link(_ref3) {
	var active = _ref3.active;
	var children = _ref3.children;
	var _onClick = _ref3.onClick;

	if (active) {
		return React.createElement(
			'span',
			null,
			children
		);
	}
	return React.createElement(
		'a',
		{ href: '#',
			onClick: function onClick(e) {
				e.preventDefault();
				_onClick();
			}
		},
		children
	);
};

var mapStateToLinkProps = function mapStateToLinkProps(state, ownProps) {
	return {
		active: ownProps.filter === state.visibilityFilter
	};
};

var mapDispatchToLinkProps = function mapDispatchToLinkProps(dispatch, ownProps) {
	return {
		onClick: function onClick() {
			dispatch(setVisibilityFilter(ownProps.filter));
		}
	};
};

var FilterLink = connect(mapStateToLinkProps, mapDispatchToLinkProps)(Link);

var Footer = function Footer() {
	return React.createElement(
		'p',
		null,
		'Show:',
		' ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_ALL'
			},
			'All'
		),
		', ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_ACTIVE'
			},
			'Active'
		),
		', ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_COMPLETED'
			},
			'Completed'
		)
	);
};

var AddTodo = function AddTodo(_ref4) {
	var dispatch = _ref4.dispatch;

	var input = undefined;

	return React.createElement(
		'div',
		null,
		React.createElement('input', { ref: function ref(node) {
				input = node;
			} }),
		React.createElement(
			'button',
			{ onClick: function onClick() {
					dispatch(addTodo(input.value));
					input.value = '';
				} },
			'Add Todo'
		)
	);
};
AddTodo = connect()(AddTodo);

var getVisibleTodos = function getVisibleTodos(todos, filter) {
	switch (filter) {
		case 'SHOW_ALL':
			return todos;

		case 'SHOW_COMPLETED':
			return todos.filter(function (t) {
				return t.completed;
			});

		case 'SHOW_ACTIVE':
			return todos.filter(function (t) {
				return !t.completed;
			});
	}
};

var mapStateToTodoListProps = function mapStateToTodoListProps(state) {
	return {
		todos: getVisibleTodos(state.todos, state.visibilityFilter)
	};
};
var mapDispatchToTodoListProps = function mapDispatchToTodoListProps(dispatch) {
	return {
		onTodoClick: function onTodoClick(id) {
			dispatch(toggleTodo(id));
		}
	};
};
var VisibleTodoList = connect(mapStateToTodoListProps, mapDispatchToTodoListProps)(TodoList);

var TodoApp = function TodoApp() {
	return React.createElement(
		'div',
		null,
		React.createElement(AddTodo, null),
		React.createElement(VisibleTodoList, null),
		React.createElement(Footer, null)
	);
};

var _ReactRedux2 = ReactRedux;
var Provider = _ReactRedux2.Provider;
// ES6  via babel: import { Provider } from 'react-redux';
// ES5: var Provider = require('react-redux').Provider;

var _Redux2 = Redux;
var createStore = _Redux2.createStore;

ReactDOM.render(React.createElement(
	Provider,
	{ store: createStore(todoApp) },
	React.createElement(TodoApp, null)
), document.getElementById('root'));

},{"deep-freeze-strict":1,"expect":7}]},{},[13])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZGVlcC1mcmVlemUtc3RyaWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V4cGVjdC9saWIvRXhwZWN0YXRpb24uanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L2xpYi9TcHlVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL1Rlc3RVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V4cGVjdC9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L25vZGVfbW9kdWxlcy9pcy1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsInNyYy8yMF9FeHRyYWN0aW5nX0FjdGlvbl9DcmVhdG9ycy9tYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQy9Jc0IsS0FBSztJQUFuQixTQUFTLFVBQVQsU0FBUzthQUVXLEtBQUs7SUFBekIsZUFBZSxVQUFmLGVBQWU7a0JBRUgsVUFBVTtJQUF0QixPQUFPLGVBQVAsT0FBTzs7O0FBR2YsSUFBTSxJQUFJLEdBQUcsU0FBUCxJQUFJLENBQUksS0FBSyxFQUFFLE1BQU0sRUFBSztBQUMvQixTQUFPLE1BQU0sQ0FBQyxJQUFJO0FBQ2pCLE9BQUssVUFBVTtBQUNkLFVBQU87QUFDTixNQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUU7QUFDYixRQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7QUFDakIsYUFBUyxFQUFFLEtBQUs7SUFDaEIsQ0FBQzs7QUFBQSxBQUVILE9BQUssYUFBYTtBQUNqQixPQUFHLEtBQUssQ0FBQyxFQUFFLEtBQUssTUFBTSxDQUFDLEVBQUUsRUFBRTtBQUMxQixXQUFPLEtBQUssQ0FBQztJQUNiOztBQUVELFVBQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7O0FBQUEsQUFFcEU7QUFDQyxVQUFPLEtBQUssQ0FBQztBQUFBLEVBQ2Q7Q0FDRCxDQUFDOztBQUdGLElBQU0sS0FBSyxHQUFHLFNBQVIsS0FBSyxHQUEyQjtLQUF2QixLQUFLLHlEQUFHLEVBQUU7S0FBRSxNQUFNOztBQUNoQyxTQUFPLE1BQU0sQ0FBQyxJQUFJO0FBQ2pCLE9BQUssVUFBVTtBQUNkLHVDQUNJLEtBQUssSUFDUixJQUFJLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxHQUN0Qjs7QUFBQSxBQUVILE9BQUssYUFBYTtBQUNqQixVQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDO1dBQUksSUFBSSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUM7SUFBQSxDQUFDLENBQUM7O0FBQUEsQUFFeEM7QUFDQyxVQUFPLEtBQUssQ0FBQztBQUFBLEVBQ2Q7Q0FDRCxDQUFDOztBQUVGLElBQU0sZ0JBQWdCLEdBQUcsU0FBbkIsZ0JBQWdCLEdBR2pCO0tBRkosS0FBSyx5REFBRyxVQUFVO0tBQ2xCLE1BQU07O0FBRU4sU0FBTyxNQUFNLENBQUMsSUFBSTtBQUNqQixPQUFLLHVCQUF1QjtBQUMzQixVQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7O0FBQUEsQUFFdEI7QUFDQyxVQUFPLEtBQUssQ0FBQztBQUFBLEVBQ2Q7Q0FDRCxDQUFDOztBQUVGLElBQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQzs7QUFFL0IsTUFBSyxFQUFMLEtBQUs7QUFDTCxpQkFBZ0IsRUFBaEI7Ozs7OztBQUFnQixDQU1oQixDQUFDLENBQUM7O0FBRUgsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLElBQU0sT0FBTyxHQUFHLFNBQVYsT0FBTyxDQUFJLElBQUksRUFBSztBQUN6QixRQUFPO0FBQ04sTUFBSSxFQUFFLFVBQVU7QUFDaEIsSUFBRSxFQUFFLFVBQVUsRUFBRTtBQUNoQixNQUFJLEVBQUosSUFBSTtFQUNKLENBQUM7Q0FDRixDQUFDOztBQUVGLElBQU0sVUFBVSxHQUFHLFNBQWIsVUFBVSxDQUFJLEVBQUUsRUFBSztBQUMxQixRQUFPO0FBQ04sTUFBSSxFQUFFLGFBQWE7QUFDbkIsSUFBRSxFQUFGLEVBQUU7RUFDRixDQUFDO0NBQ0YsQ0FBQzs7QUFFRixJQUFNLElBQUksR0FBRyxTQUFQLElBQUk7S0FDVCxPQUFPLFFBQVAsT0FBTztLQUNQLFNBQVMsUUFBVCxTQUFTO0tBQ1QsSUFBSSxRQUFKLElBQUk7UUFFSjs7O0FBQ0MsVUFBTyxFQUNOLE9BQU8sQUFDUDtBQUNELFFBQUssRUFBRTtBQUNOLGtCQUFjLEVBQ2IsU0FBUyxHQUNSLGNBQWMsR0FDZCxNQUFNO0lBQ1IsQUFBQzs7RUFFRCxJQUFJO0VBQ0Q7Q0FDTCxDQUFDOztBQUVGLElBQU0sUUFBUSxHQUFHLFNBQVgsUUFBUTtLQUNiLEtBQUssU0FBTCxLQUFLO0tBQ0wsV0FBVyxTQUFYLFdBQVc7UUFFWDs7O0VBQ0UsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFBLElBQUk7VUFDZCxvQkFBQyxJQUFJO0FBQ0osT0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEFBQUM7TUFDVCxJQUFJO0FBQ1IsV0FBTyxFQUFFO1lBQU0sV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7S0FBQSxBQUFDO01BQ25DO0dBQUEsQ0FDRjtFQUNHO0NBQ0wsQ0FBQzs7QUFFRixJQUFNLG1CQUFtQixHQUFHLFNBQXRCLG1CQUFtQixDQUFJLE1BQU0sRUFBSztBQUN2QyxRQUFPO0FBQ04sTUFBSSxFQUFFLHVCQUF1QjtBQUM3QixRQUFNLEVBQU4sTUFBTTtFQUNOLENBQUM7Q0FDRixDQUFDOztBQUVGLElBQU0sSUFBSSxHQUFHLFNBQVAsSUFBSSxRQUlKO0tBSEwsTUFBTSxTQUFOLE1BQU07S0FDTixRQUFRLFNBQVIsUUFBUTtLQUNSLFFBQU8sU0FBUCxPQUFPOztBQUVQLEtBQUcsTUFBTSxFQUFFO0FBQ1YsU0FBTzs7O0dBQU8sUUFBUTtHQUFRLENBQUM7RUFDL0I7QUFDRCxRQUNDOztJQUFHLElBQUksRUFBQyxHQUFHO0FBQ1YsVUFBTyxFQUFFLGlCQUFBLENBQUMsRUFBSTtBQUNiLEtBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUNuQixZQUFPLEVBQUUsQ0FBQztJQUNWLEFBQUM7O0VBRUQsUUFBUTtFQUNOLENBQ0g7Q0FDRixDQUFDOztBQUVGLElBQU0sbUJBQW1CLEdBQUcsU0FBdEIsbUJBQW1CLENBQ3hCLEtBQUssRUFDTCxRQUFRLEVBQ0o7QUFDSixRQUFPO0FBQ04sUUFBTSxFQUNMLFFBQVEsQ0FBQyxNQUFNLEtBQ2YsS0FBSyxDQUFDLGdCQUFnQjtFQUN2QixDQUFDO0NBQ0YsQ0FBQzs7QUFFRixJQUFNLHNCQUFzQixHQUFHLFNBQXpCLHNCQUFzQixDQUMzQixRQUFRLEVBQ1IsUUFBUSxFQUNKO0FBQ0osUUFBTztBQUNOLFNBQU8sRUFBRSxtQkFBTTtBQUNkLFdBQVEsQ0FDUCxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQ3BDLENBQUM7R0FDRjtFQUNELENBQUM7Q0FDRixDQUFDOztBQUVGLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FDekIsbUJBQW1CLEVBQ25CLHNCQUFzQixDQUN0QixDQUFDLElBQUksQ0FBQyxDQUFDOztBQUVSLElBQU0sTUFBTSxHQUFHLFNBQVQsTUFBTTtRQUNYOzs7O0VBRUUsR0FBRztFQUNKO0FBQUMsYUFBVTs7QUFDVixVQUFNLEVBQUMsVUFBVTs7O0dBR0w7RUFDWixJQUFJO0VBQ0w7QUFBQyxhQUFVOztBQUNWLFVBQU0sRUFBQyxhQUFhOzs7R0FHUjtFQUNaLElBQUk7RUFDTDtBQUFDLGFBQVU7O0FBQ1YsVUFBTSxFQUFDLGdCQUFnQjs7O0dBR1g7RUFDVjtDQUNKLENBQUM7O0FBRUYsSUFBSSxPQUFPLEdBQUcsd0JBRVI7S0FETCxRQUFRLFNBQVIsUUFBUTs7QUFFUixLQUFJLEtBQUssWUFBQSxDQUFDOztBQUVWLFFBQ0M7OztFQUNDLCtCQUFPLEdBQUcsRUFBRSxhQUFBLElBQUksRUFBSTtBQUNuQixTQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ2IsQUFBQyxHQUFHO0VBQ0w7O0tBQVEsT0FBTyxFQUFFLG1CQUFNO0FBQ3RCLGFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDL0IsVUFBSyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7S0FDakIsQUFBQzs7R0FFTztFQUNKLENBQ0w7Q0FDRixDQUFDO0FBQ0YsT0FBTyxHQUFHLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDOztBQUU3QixJQUFNLGVBQWUsR0FBRyxTQUFsQixlQUFlLENBQ3BCLEtBQUssRUFDTCxNQUFNLEVBQ0Y7QUFDSixTQUFPLE1BQU07QUFDWixPQUFLLFVBQVU7QUFDZCxVQUFPLEtBQUssQ0FBQzs7QUFBQSxBQUVkLE9BQUssZ0JBQWdCO0FBQ3BCLFVBQU8sS0FBSyxDQUFDLE1BQU0sQ0FDbEIsVUFBQSxDQUFDO1dBQUksQ0FBQyxDQUFDLFNBQVM7SUFBQSxDQUNoQixDQUFDOztBQUFBLEFBRUgsT0FBSyxhQUFhO0FBQ2pCLFVBQU8sS0FBSyxDQUFDLE1BQU0sQ0FDbEIsVUFBQSxDQUFDO1dBQUksQ0FBQyxDQUFDLENBQUMsU0FBUztJQUFBLENBQ2pCLENBQUM7QUFBQSxFQUNIO0NBQ0QsQ0FBQzs7QUFFRixJQUFNLHVCQUF1QixHQUFHLFNBQTFCLHVCQUF1QixDQUM1QixLQUFLLEVBQ0Q7QUFDSixRQUFPO0FBQ04sT0FBSyxFQUFFLGVBQWUsQ0FDckIsS0FBSyxDQUFDLEtBQUssRUFDWCxLQUFLLENBQUMsZ0JBQWdCLENBQ3RCO0VBQ0QsQ0FBQztDQUNGLENBQUM7QUFDRixJQUFNLDBCQUEwQixHQUFHLFNBQTdCLDBCQUEwQixDQUMvQixRQUFRLEVBQ0o7QUFDSixRQUFPO0FBQ04sYUFBVyxFQUFFLHFCQUFDLEVBQUUsRUFBSztBQUNwQixXQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7R0FDekI7RUFDRCxDQUFDO0NBQ0YsQ0FBQztBQUNGLElBQU0sZUFBZSxHQUFHLE9BQU8sQ0FDOUIsdUJBQXVCLEVBQ3ZCLDBCQUEwQixDQUMxQixDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUVaLElBQU0sT0FBTyxHQUFHLFNBQVYsT0FBTztRQUNaOzs7RUFDQyxvQkFBQyxPQUFPLE9BQUc7RUFDWCxvQkFBQyxlQUFlLE9BQUc7RUFDbkIsb0JBQUMsTUFBTSxPQUFHO0VBQ0w7Q0FDTixDQUFDOzttQkFFbUIsVUFBVTtJQUF2QixRQUFRLGdCQUFSLFFBQVE7Ozs7Y0FJUSxLQUFLO0lBQXJCLFdBQVcsV0FBWCxXQUFXOztBQUVuQixRQUFRLENBQUMsTUFBTSxDQUNkO0FBQUMsU0FBUTtHQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsT0FBTyxDQUFDLEFBQUM7Q0FDckMsb0JBQUMsT0FBTyxPQUFHO0NBQ0QsRUFDWCxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUMvQixDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVlcEZyZWV6ZSAobykge1xuICBPYmplY3QuZnJlZXplKG8pO1xuXG4gIHZhciBvSXNGdW5jdGlvbiA9IHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCI7XG4gIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKGhhc093blByb3AuY2FsbChvLCBwcm9wKVxuICAgICYmIChvSXNGdW5jdGlvbiA/IHByb3AgIT09ICdjYWxsZXInICYmIHByb3AgIT09ICdjYWxsZWUnICYmIHByb3AgIT09ICdhcmd1bWVudHMnIDogdHJ1ZSApXG4gICAgJiYgb1twcm9wXSAhPT0gbnVsbFxuICAgICYmICh0eXBlb2Ygb1twcm9wXSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb1twcm9wXSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICYmICFPYmplY3QuaXNGcm96ZW4ob1twcm9wXSkpIHtcbiAgICAgIGRlZXBGcmVlemUob1twcm9wXSk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIF9kZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbnZhciBfaXNSZWdleHAgPSByZXF1aXJlKCdpcy1yZWdleHAnKTtcblxudmFyIF9pc1JlZ2V4cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1JlZ2V4cCk7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcblxudmFyIF9hc3NlcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzZXJ0KTtcblxudmFyIF9TcHlVdGlscyA9IHJlcXVpcmUoJy4vU3B5VXRpbHMnKTtcblxudmFyIF9UZXN0VXRpbHMgPSByZXF1aXJlKCcuL1Rlc3RVdGlscycpO1xuXG4vKipcbiAqIEFuIEV4cGVjdGF0aW9uIGlzIGEgd3JhcHBlciBhcm91bmQgYW4gYXNzZXJ0aW9uIHRoYXQgYWxsb3dzIGl0IHRvIGJlIHdyaXR0ZW5cbiAqIGluIGEgbW9yZSBuYXR1cmFsIHN0eWxlLCB3aXRob3V0IHRoZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBvcmRlciBvZiBhcmd1bWVudHMuXG4gKiBUaGlzIGhlbHBzIHByZXZlbnQgeW91IGZyb20gbWFraW5nIG1pc3Rha2VzIHdoZW4gd3JpdGluZyB0ZXN0cy5cbiAqL1xuXG52YXIgRXhwZWN0YXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHBlY3RhdGlvbihhY3R1YWwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwZWN0YXRpb24pO1xuXG4gICAgdGhpcy5hY3R1YWwgPSBhY3R1YWw7XG5cbiAgICBpZiAoX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKGFjdHVhbCkpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmFyZ3MgPSBbXTtcbiAgICB9XG4gIH1cblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9FeGlzdCA9IGZ1bmN0aW9uIHRvRXhpc3QobWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odGhpcy5hY3R1YWwsIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGV4aXN0JywgdGhpcy5hY3R1YWwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvTm90RXhpc3QgPSBmdW5jdGlvbiB0b05vdEV4aXN0KG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKCF0aGlzLmFjdHVhbCwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gbm90IGV4aXN0JywgdGhpcy5hY3R1YWwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvQmUgPSBmdW5jdGlvbiB0b0JlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0aGlzLmFjdHVhbCA9PT0gdmFsdWUsIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGJlICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b05vdEJlID0gZnVuY3Rpb24gdG9Ob3RCZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odGhpcy5hY3R1YWwgIT09IHZhbHVlLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBub3QgYmUgJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvRXF1YWwgPSBmdW5jdGlvbiB0b0VxdWFsKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXSh0aGlzLmFjdHVhbCwgdmFsdWUpLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBlcXVhbCAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVGhlc2UgYXR0cmlidXRlcyBhcmUgY29uc3VtZWQgYnkgTW9jaGEgdG8gcHJvZHVjZSBhIGRpZmYgb3V0cHV0LlxuICAgICAgZS5zaG93RGlmZiA9IHRydWU7XG4gICAgICBlLmFjdHVhbCA9IHRoaXMuYWN0dWFsO1xuICAgICAgZS5leHBlY3RlZCA9IHZhbHVlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9Ob3RFcXVhbCA9IGZ1bmN0aW9uIHRvTm90RXF1YWwodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKCFfZGVlcEVxdWFsMlsnZGVmYXVsdCddKHRoaXMuYWN0dWFsLCB2YWx1ZSksIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIG5vdCBlcXVhbCAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9UaHJvdyA9IGZ1bmN0aW9uIHRvVGhyb3codmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNGdW5jdGlvbih0aGlzLmFjdHVhbCksICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b1Rocm93KCkgbXVzdCBiZSBhIGZ1bmN0aW9uLCAlcyB3YXMgZ2l2ZW4nLCB0aGlzLmFjdHVhbCk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuZnVuY3Rpb25UaHJvd3ModGhpcy5hY3R1YWwsIHRoaXMuY29udGV4dCwgdGhpcy5hcmdzLCB2YWx1ZSksIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIHRocm93ICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlIHx8ICdhbiBlcnJvcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvTm90VGhyb3cgPSBmdW5jdGlvbiB0b05vdFRocm93KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzRnVuY3Rpb24odGhpcy5hY3R1YWwpLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9Ob3RUaHJvdygpIG11c3QgYmUgYSBmdW5jdGlvbiwgJXMgd2FzIGdpdmVuJywgdGhpcy5hY3R1YWwpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSghX1Rlc3RVdGlscy5mdW5jdGlvblRocm93cyh0aGlzLmFjdHVhbCwgdGhpcy5jb250ZXh0LCB0aGlzLmFyZ3MsIHZhbHVlKSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gbm90IHRocm93ICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlIHx8ICdhbiBlcnJvcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvQmVBID0gZnVuY3Rpb24gdG9CZUEodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgaW4gdG9CZUEodmFsdWUpIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzQSh0aGlzLmFjdHVhbCwgdmFsdWUpLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBiZSBhICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b05vdEJlQSA9IGZ1bmN0aW9uIHRvTm90QmVBKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzRnVuY3Rpb24odmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IGluIHRvTm90QmVBKHZhbHVlKSBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oIV9UZXN0VXRpbHMuaXNBKHRoaXMuYWN0dWFsLCB2YWx1ZSksIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGJlIGEgJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvTWF0Y2ggPSBmdW5jdGlvbiB0b01hdGNoKHBhdHRlcm4sIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHR5cGVvZiB0aGlzLmFjdHVhbCA9PT0gJ3N0cmluZycsICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b01hdGNoKCkgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfaXNSZWdleHAyWydkZWZhdWx0J10ocGF0dGVybiksICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IGluIHRvTWF0Y2godmFsdWUpIG11c3QgYmUgYSBSZWdFeHAnKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10ocGF0dGVybi50ZXN0KHRoaXMuYWN0dWFsKSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gbWF0Y2ggJXMnLCB0aGlzLmFjdHVhbCwgcGF0dGVybik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9Ob3RNYXRjaCA9IGZ1bmN0aW9uIHRvTm90TWF0Y2gocGF0dGVybiwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odHlwZW9mIHRoaXMuYWN0dWFsID09PSAnc3RyaW5nJywgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvTm90TWF0Y2goKSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9pc1JlZ2V4cDJbJ2RlZmF1bHQnXShwYXR0ZXJuKSwgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgaW4gdG9Ob3RNYXRjaCh2YWx1ZSkgbXVzdCBiZSBhIFJlZ0V4cCcpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSghcGF0dGVybi50ZXN0KHRoaXMuYWN0dWFsKSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gbm90IG1hdGNoICVzJywgdGhpcy5hY3R1YWwsIHBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvQmVMZXNzVGhhbiA9IGZ1bmN0aW9uIHRvQmVMZXNzVGhhbih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odHlwZW9mIHRoaXMuYWN0dWFsID09PSAnbnVtYmVyJywgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvQmVMZXNzVGhhbigpIG11c3QgYmUgYSBudW1iZXInKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgaW4gdG9CZUxlc3NUaGFuKHZhbHVlKSBtdXN0IGJlIGEgbnVtYmVyJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHRoaXMuYWN0dWFsIDwgdmFsdWUsIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGJlIGxlc3MgdGhhbiAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9CZUdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gdG9CZUdyZWF0ZXJUaGFuKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0eXBlb2YgdGhpcy5hY3R1YWwgPT09ICdudW1iZXInLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9CZUdyZWF0ZXJUaGFuKCkgbXVzdCBiZSBhIG51bWJlcicpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBpbiB0b0JlR3JlYXRlclRoYW4odmFsdWUpIG11c3QgYmUgYSBudW1iZXInKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odGhpcy5hY3R1YWwgPiB2YWx1ZSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gYmUgZ3JlYXRlciB0aGFuICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0luY2x1ZGUgPSBmdW5jdGlvbiB0b0luY2x1ZGUodmFsdWUsIGNvbXBhcmF0b3IsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNBcnJheSh0aGlzLmFjdHVhbCkgfHwgdHlwZW9mIHRoaXMuYWN0dWFsID09PSAnc3RyaW5nJywgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvSW5jbHVkZSgpIG11c3QgYmUgYW4gYXJyYXkgb3IgYSBzdHJpbmcnKTtcblxuICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1lc3NhZ2UgPSBjb21wYXJhdG9yO1xuICAgICAgY29tcGFyYXRvciA9IG51bGw7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGluY2x1ZGUgJXMnO1xuXG4gICAgaWYgKF9UZXN0VXRpbHMuaXNBcnJheSh0aGlzLmFjdHVhbCkpIHtcbiAgICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5hcnJheUNvbnRhaW5zKHRoaXMuYWN0dWFsLCB2YWx1ZSwgY29tcGFyYXRvciksIG1lc3NhZ2UsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5zdHJpbmdDb250YWlucyh0aGlzLmFjdHVhbCwgdmFsdWUpLCBtZXNzYWdlLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0V4Y2x1ZGUgPSBmdW5jdGlvbiB0b0V4Y2x1ZGUodmFsdWUsIGNvbXBhcmF0b3IsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNBcnJheSh0aGlzLmFjdHVhbCkgfHwgdHlwZW9mIHRoaXMuYWN0dWFsID09PSAnc3RyaW5nJywgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvRXhjbHVkZSgpIG11c3QgYmUgYW4gYXJyYXkgb3IgYSBzdHJpbmcnKTtcblxuICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1lc3NhZ2UgPSBjb21wYXJhdG9yO1xuICAgICAgY29tcGFyYXRvciA9IG51bGw7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGV4Y2x1ZGUgJXMnO1xuXG4gICAgaWYgKF9UZXN0VXRpbHMuaXNBcnJheSh0aGlzLmFjdHVhbCkpIHtcbiAgICAgIF9hc3NlcnQyWydkZWZhdWx0J10oIV9UZXN0VXRpbHMuYXJyYXlDb250YWlucyh0aGlzLmFjdHVhbCwgdmFsdWUsIGNvbXBhcmF0b3IpLCBtZXNzYWdlLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKCFfVGVzdFV0aWxzLnN0cmluZ0NvbnRhaW5zKHRoaXMuYWN0dWFsLCB2YWx1ZSksIG1lc3NhZ2UsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvSGF2ZUJlZW5DYWxsZWQgPSBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkKG1lc3NhZ2UpIHtcbiAgICB2YXIgc3B5ID0gdGhpcy5hY3R1YWw7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9TcHlVdGlscy5pc1NweShzcHkpLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9IYXZlQmVlbkNhbGxlZCgpIG11c3QgYmUgYSBzcHknKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oc3B5LmNhbGxzLmxlbmd0aCA+IDAsIG1lc3NhZ2UgfHwgJ3NweSB3YXMgbm90IGNhbGxlZCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvSGF2ZUJlZW5DYWxsZWRXaXRoID0gZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZFdpdGgoKSB7XG4gICAgdmFyIHNweSA9IHRoaXMuYWN0dWFsO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfU3B5VXRpbHMuaXNTcHkoc3B5KSwgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCkgbXVzdCBiZSBhIHNweScpO1xuXG4gICAgdmFyIGV4cGVjdGVkQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHNweS5jYWxscy5zb21lKGZ1bmN0aW9uIChjYWxsKSB7XG4gICAgICByZXR1cm4gX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShjYWxsLmFyZ3VtZW50cywgZXhwZWN0ZWRBcmdzKTtcbiAgICB9KSwgJ3NweSB3YXMgbmV2ZXIgY2FsbGVkIHdpdGggJXMnLCBleHBlY3RlZEFyZ3MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvTm90SGF2ZUJlZW5DYWxsZWQgPSBmdW5jdGlvbiB0b05vdEhhdmVCZWVuQ2FsbGVkKG1lc3NhZ2UpIHtcbiAgICB2YXIgc3B5ID0gdGhpcy5hY3R1YWw7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9TcHlVdGlscy5pc1NweShzcHkpLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9Ob3RIYXZlQmVlbkNhbGxlZCgpIG11c3QgYmUgYSBzcHknKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oc3B5LmNhbGxzLmxlbmd0aCA9PT0gMCwgbWVzc2FnZSB8fCAnc3B5IHdhcyBub3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUud2l0aENvbnRleHQgPSBmdW5jdGlvbiB3aXRoQ29udGV4dChjb250ZXh0KSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzRnVuY3Rpb24odGhpcy5hY3R1YWwpLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkud2l0aENvbnRleHQoKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUud2l0aEFyZ3MgPSBmdW5jdGlvbiB3aXRoQXJncygpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNGdW5jdGlvbih0aGlzLmFjdHVhbCksICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS53aXRoQXJncygpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHRoaXMuYXJncyA9IHRoaXMuYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gRXhwZWN0YXRpb247XG59KSgpO1xuXG52YXIgYWxpYXNlcyA9IHtcbiAgdG9CZUFuOiAndG9CZUEnLFxuICB0b05vdEJlQW46ICd0b05vdEJlQScsXG4gIHRvQmVUcnV0aHk6ICd0b0V4aXN0JyxcbiAgdG9CZUZhbHN5OiAndG9Ob3RFeGlzdCcsXG4gIHRvQmVGZXdlclRoYW46ICd0b0JlTGVzc1RoYW4nLFxuICB0b0JlTW9yZVRoYW46ICd0b0JlR3JlYXRlclRoYW4nLFxuICB0b0NvbnRhaW46ICd0b0luY2x1ZGUnLFxuICB0b05vdENvbnRhaW46ICd0b0V4Y2x1ZGUnXG59O1xuXG5mb3IgKHZhciBhbGlhcyBpbiBhbGlhc2VzKSB7XG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZVthbGlhc10gPSBFeHBlY3RhdGlvbi5wcm90b3R5cGVbYWxpYXNlc1thbGlhc11dO1xufWV4cG9ydHNbJ2RlZmF1bHQnXSA9IEV4cGVjdGF0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jcmVhdGVTcHkgPSBjcmVhdGVTcHk7XG5leHBvcnRzLnNweU9uID0gc3B5T247XG5leHBvcnRzLmlzU3B5ID0gaXNTcHk7XG5leHBvcnRzLnJlc3RvcmVTcGllcyA9IHJlc3RvcmVTcGllcztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5cbnZhciBfYXNzZXJ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydCk7XG5cbnZhciBfVGVzdFV0aWxzID0gcmVxdWlyZSgnLi9UZXN0VXRpbHMnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBzcGllcyA9IFtdO1xuXG5mdW5jdGlvbiBjcmVhdGVTcHkoZm4pIHtcbiAgdmFyIHJlc3RvcmUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBub29wIDogYXJndW1lbnRzWzFdO1xuXG4gIGlmIChmbiA9PSBudWxsKSBmbiA9IG5vb3A7XG5cbiAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzRnVuY3Rpb24oZm4pLCAnY3JlYXRlU3B5IG5lZWRzIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgdGFyZ2V0Rm4gPSB1bmRlZmluZWQsXG4gICAgICB0aHJvd25WYWx1ZSA9IHVuZGVmaW5lZCxcbiAgICAgIHJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciBzcHkgPSBmdW5jdGlvbiBzcHkoKSB7XG4gICAgc3B5LmNhbGxzLnB1c2goe1xuICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgIGFyZ3VtZW50czogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgIH0pO1xuXG4gICAgaWYgKHRhcmdldEZuKSByZXR1cm4gdGFyZ2V0Rm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aHJvd25WYWx1ZSkgdGhyb3cgdGhyb3duVmFsdWU7XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH07XG5cbiAgc3B5LmNhbGxzID0gW107XG5cbiAgc3B5LmFuZENhbGwgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB0YXJnZXRGbiA9IGZuO1xuICAgIHJldHVybiBzcHk7XG4gIH07XG5cbiAgc3B5LmFuZENhbGxUaHJvdWdoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzcHkuYW5kQ2FsbChmbik7XG4gIH07XG5cbiAgc3B5LmFuZFRocm93ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHRocm93blZhbHVlID0gb2JqZWN0O1xuICAgIHJldHVybiBzcHk7XG4gIH07XG5cbiAgc3B5LmFuZFJldHVybiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVyblZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHNweTtcbiAgfTtcblxuICBzcHkuZ2V0TGFzdENhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNweS5jYWxsc1tzcHkuY2FsbHMubGVuZ3RoIC0gMV07XG4gIH07XG5cbiAgc3B5LnJlc3RvcmUgPSBzcHkuZGVzdHJveSA9IHJlc3RvcmU7XG5cbiAgc3B5Ll9faXNTcHkgPSB0cnVlO1xuXG4gIHNwaWVzLnB1c2goc3B5KTtcblxuICByZXR1cm4gc3B5O1xufVxuXG5mdW5jdGlvbiBzcHlPbihvYmplY3QsIG1ldGhvZE5hbWUpIHtcbiAgdmFyIG9yaWdpbmFsID0gb2JqZWN0W21ldGhvZE5hbWVdO1xuXG4gIGlmICghaXNTcHkob3JpZ2luYWwpKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzRnVuY3Rpb24ob3JpZ2luYWwpLCAnQ2Fubm90IHNweU9uIHRoZSAlcyBwcm9wZXJ0eTsgaXQgaXMgbm90IGEgZnVuY3Rpb24nLCBtZXRob2ROYW1lKTtcblxuICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGNyZWF0ZVNweShvcmlnaW5hbCwgZnVuY3Rpb24gKCkge1xuICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gb3JpZ2luYWw7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W21ldGhvZE5hbWVdO1xufVxuXG5mdW5jdGlvbiBpc1NweShvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX19pc1NweSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVNwaWVzKCkge1xuICBmb3IgKHZhciBpID0gc3BpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBzcGllc1tpXS5yZXN0b3JlKCk7XG4gIH1zcGllcyA9IFtdO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZnVuY3Rpb25UaHJvd3MgPSBmdW5jdGlvblRocm93cztcbmV4cG9ydHMuYXJyYXlDb250YWlucyA9IGFycmF5Q29udGFpbnM7XG5leHBvcnRzLnN0cmluZ0NvbnRhaW5zID0gc3RyaW5nQ29udGFpbnM7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNBID0gaXNBO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX2lzUmVnZXhwID0gcmVxdWlyZSgnaXMtcmVnZXhwJyk7XG5cbnZhciBfaXNSZWdleHAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNSZWdleHApO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gdGhyb3dzIHRoZSBnaXZlbiB2YWx1ZVxuICogd2hlbiBpbnZva2VkLiBUaGUgdmFsdWUgbWF5IGJlOlxuICpcbiAqIC0gdW5kZWZpbmVkLCB0byBtZXJlbHkgYXNzZXJ0IHRoZXJlIHdhcyBhIHRocm93XG4gKiAtIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIGZvciBjb21wYXJpbmcgdXNpbmcgaW5zdGFuY2VvZlxuICogLSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgdG8gY29tcGFyZSB3aXRoIHRoZSBlcnJvciBtZXNzYWdlXG4gKiAtIGEgc3RyaW5nLCB0byBmaW5kIGluIHRoZSBlcnJvciBtZXNzYWdlXG4gKi9cblxuZnVuY3Rpb24gZnVuY3Rpb25UaHJvd3MoZm4sIGNvbnRleHQsIGFyZ3MsIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGVycm9yIGluc3RhbmNlb2YgdmFsdWUpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8IGVycm9yO1xuXG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKF9pc1JlZ2V4cDJbJ2RlZmF1bHQnXSh2YWx1ZSkgJiYgdmFsdWUudGVzdChlcnJvci5tZXNzYWdlKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIG1lc3NhZ2UuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBhcnJheSBjb250YWlucyB0aGUgdmFsdWUsIGZhbHNlXG4gKiBvdGhlcndpc2UuIFRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGZhbHNlIHRvXG4gKiBpbmRpY2F0ZSBhIG5vbi1tYXRjaC5cbiAqL1xuXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICBpZiAoY29tcGFyYXRvciA9PSBudWxsKSBjb21wYXJhdG9yID0gX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXTtcblxuICByZXR1cm4gYXJyYXkuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBjb21wYXJhdG9yKGl0ZW0sIHZhbHVlKSAhPT0gZmFsc2U7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIHRoZSB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ0NvbnRhaW5zKHN0cmluZywgdmFsdWUpIHtcbiAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gYXJyYXkuXG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheShvYmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlb2YgdmFsdWVcbiAqIG9yIGl0cyB0eXBlb2YgaXMgdGhlIGdpdmVuIHZhbHVlLlxuICovXG5cbmZ1bmN0aW9uIGlzQShvYmplY3QsIHZhbHVlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gJ2FycmF5JykgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqZWN0KTtcblxuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gdmFsdWU7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfb2JqZWN0SW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG5cbnZhciBfb2JqZWN0SW5zcGVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3RJbnNwZWN0KTtcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZUZvcm1hdCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZXh0cmFBcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGV4dHJhQXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoY29uZGl0aW9uKSByZXR1cm47XG5cbiAgdmFyIGluZGV4ID0gMDtcblxuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9vYmplY3RJbnNwZWN0MlsnZGVmYXVsdCddKGV4dHJhQXJnc1tpbmRleCsrXSk7XG4gIH0pKTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gYXNzZXJ0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfRXhwZWN0YXRpb24gPSByZXF1aXJlKCcuL0V4cGVjdGF0aW9uJyk7XG5cbnZhciBfRXhwZWN0YXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXhwZWN0YXRpb24pO1xuXG52YXIgRXh0ZW5zaW9ucyA9IFtdO1xuXG5mdW5jdGlvbiBleHRlbmQoZXh0ZW5zaW9uKSB7XG4gIGlmIChFeHRlbnNpb25zLmluZGV4T2YoZXh0ZW5zaW9uKSA9PT0gLTEpIHtcbiAgICBFeHRlbnNpb25zLnB1c2goZXh0ZW5zaW9uKTtcblxuICAgIGZvciAodmFyIHAgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICBpZiAoZXh0ZW5zaW9uLmhhc093blByb3BlcnR5KHApKSBfRXhwZWN0YXRpb24yWydkZWZhdWx0J10ucHJvdG90eXBlW3BdID0gZXh0ZW5zaW9uW3BdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBleHRlbmQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9FeHBlY3RhdGlvbiA9IHJlcXVpcmUoJy4vRXhwZWN0YXRpb24nKTtcblxudmFyIF9FeHBlY3RhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FeHBlY3RhdGlvbik7XG5cbnZhciBfU3B5VXRpbHMgPSByZXF1aXJlKCcuL1NweVV0aWxzJyk7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcblxudmFyIF9hc3NlcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzZXJ0KTtcblxudmFyIF9leHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuXG52YXIgX2V4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leHRlbmQpO1xuXG5mdW5jdGlvbiBleHBlY3QoYWN0dWFsKSB7XG4gIHJldHVybiBuZXcgX0V4cGVjdGF0aW9uMlsnZGVmYXVsdCddKGFjdHVhbCk7XG59XG5cbmV4cGVjdC5jcmVhdGVTcHkgPSBfU3B5VXRpbHMuY3JlYXRlU3B5O1xuZXhwZWN0LnNweU9uID0gX1NweVV0aWxzLnNweU9uO1xuZXhwZWN0LmlzU3B5ID0gX1NweVV0aWxzLmlzU3B5O1xuZXhwZWN0LnJlc3RvcmVTcGllcyA9IF9TcHlVdGlscy5yZXN0b3JlU3BpZXM7XG5leHBlY3QuYXNzZXJ0ID0gX2Fzc2VydDJbJ2RlZmF1bHQnXTtcbmV4cGVjdC5leHRlbmQgPSBfZXh0ZW5kMlsnZGVmYXVsdCddO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBleHBlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuIiwidmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZSkge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnNwZWN0XyAob2JqLCBvcHRzLCBkZXB0aCwgc2Vlbikge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIFxuICAgIHZhciBtYXhEZXB0aCA9IG9wdHMuZGVwdGggPT09IHVuZGVmaW5lZCA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmIChkZXB0aCA9PT0gdW5kZWZpbmVkKSBkZXB0aCA9IDA7XG4gICAgaWYgKGRlcHRoID49IG1heERlcHRoICYmIG1heERlcHRoID4gMFxuICAgICYmIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gJ1tPYmplY3RdJztcbiAgICB9XG4gICAgXG4gICAgaWYgKHNlZW4gPT09IHVuZGVmaW5lZCkgc2VlbiA9IFtdO1xuICAgIGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGluc3BlY3QgKHZhbHVlLCBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgICAgICBzZWVuID0gc2Vlbi5zbGljZSgpO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgb3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKG9iaik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lT2Yob2JqKTtcbiAgICAgICAgcmV0dXJuICdbRnVuY3Rpb24nICsgKG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnKSArICddJztcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3ltYm9sKG9iaikpIHtcbiAgICAgICAgdmFyIHN5bVN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgPyAnT2JqZWN0KCcgKyBzeW1TdHJpbmcgKyAnKScgOiBzeW1TdHJpbmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgICAgIHZhciBzID0gJzwnICsgU3RyaW5nKG9iai5ub2RlTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGF0dHJzID0gb2JqLmF0dHJpYnV0ZXMgfHwgW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHMgKz0gJyAnICsgYXR0cnNbaV0ubmFtZSArICc9XCInICsgcXVvdGUoYXR0cnNbaV0udmFsdWUpICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgcyArPSAnLi4uJztcbiAgICAgICAgcyArPSAnPC8nICsgU3RyaW5nKG9iai5ub2RlTmFtZSkudG9Mb3dlckNhc2UoKSArICc+JztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdbXSc7XG4gICAgICAgIHZhciB4cyA9IEFycmF5KG9iai5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHNbaV0gPSBoYXMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdbICcgKyB4cy5qb2luKCcsICcpICsgJyBdJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFcnJvcihvYmopKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoIWhhcyhvYmosIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoL1teXFx3JF0vLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goaW5zcGVjdChrZXkpICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goa2V5ICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKSByZXR1cm4gJ1snICsgb2JqICsgJ10nO1xuICAgICAgICByZXR1cm4gJ3sgWycgKyBvYmogKyAnXSAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmouaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gb2JqLmluc3BlY3QoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWlzRGF0ZShvYmopICYmICFpc1JlZ0V4cChvYmopKSB7XG4gICAgICAgIHZhciB4cyA9IFtdLCBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICgvW15cXHckXS8udGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgeHMucHVzaChpbnNwZWN0KGtleSkgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHhzLnB1c2goa2V5ICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4cy5sZW5ndGggPT09IDApIHJldHVybiAne30nO1xuICAgICAgICByZXR1cm4gJ3sgJyArIHhzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICBlbHNlIHJldHVybiBTdHJpbmcob2JqKTtcbn07XG5cbmZ1bmN0aW9uIHF1b3RlIChzKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyB9XG5mdW5jdGlvbiBpc0RhdGUgKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nIH1cbmZ1bmN0aW9uIGlzUmVnRXhwIChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nIH1cbmZ1bmN0aW9uIGlzRXJyb3IgKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB9XG5mdW5jdGlvbiBpc1N5bWJvbCAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBTeW1ib2xdJyB9XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSBpbiB0aGlzOyB9O1xuZnVuY3Rpb24gaGFzIChvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIGtleSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5hbWVPZiAoZikge1xuICAgIGlmIChmLm5hbWUpIHJldHVybiBmLm5hbWU7XG4gICAgdmFyIG0gPSBmLnRvU3RyaW5nKCkubWF0Y2goL15mdW5jdGlvblxccyooW1xcdyRdKykvKTtcbiAgICBpZiAobSkgcmV0dXJuIG1bMV07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50ICh4KSB7XG4gICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB4Lm5vZGVOYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAmJiB0eXBlb2YgeC5nZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbidcbiAgICA7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RTdHJpbmcgKHN0cikge1xuICAgIHZhciBzID0gc3RyLnJlcGxhY2UoLyhbJ1xcXFxdKS9nLCAnXFxcXCQxJykucmVwbGFjZSgvW1xceDAwLVxceDFmXS9nLCBsb3dieXRlKTtcbiAgICByZXR1cm4gXCInXCIgKyBzICsgXCInXCI7XG4gICAgXG4gICAgZnVuY3Rpb24gbG93Ynl0ZSAoYykge1xuICAgICAgICB2YXIgbiA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgdmFyIHggPSB7IDg6ICdiJywgOTogJ3QnLCAxMDogJ24nLCAxMjogJ2YnLCAxMzogJ3InIH1bbl07XG4gICAgICAgIGlmICh4KSByZXR1cm4gJ1xcXFwnICsgeDtcbiAgICAgICAgcmV0dXJuICdcXFxceCcgKyAobiA8IDB4MTAgPyAnMCcgOiAnJykgKyBuLnRvU3RyaW5nKDE2KTtcbiAgICB9XG59XG4iLCIvLyBVc2luZyBhbiBFUzYgdHJhbnNwaWxlciwgbGlrZSBiYWJlbCBcbmltcG9ydCBleHBlY3QgZnJvbSAnZXhwZWN0JztcbmltcG9ydCBkZWVwRnJlZXplIGZyb20gJ2RlZXAtZnJlZXplLXN0cmljdCc7XG5cbmNvbnN0IHsgQ29tcG9uZW50IH0gPSBSZWFjdDtcblxuY29uc3QgeyBjb21iaW5lUmVkdWNlcnMgfSA9IFJlZHV4O1xuXG5jb25zdCB7IGNvbm5lY3QgfSA9IFJlYWN0UmVkdXg7XG4vLyBFUzYgIHZpYSBiYWJlbDogaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuY29uc3QgdG9kbyA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG5cdHN3aXRjaChhY3Rpb24udHlwZSkge1xuXHRcdGNhc2UgJ0FERF9UT0RPJzpcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkOiBhY3Rpb24uaWQsXG5cdFx0XHRcdHRleHQ6IGFjdGlvbi50ZXh0LFxuXHRcdFx0XHRjb21wbGV0ZWQ6IGZhbHNlXG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnVE9HR0xFX1RPRE8nOlx0XHRcdFxuXHRcdFx0aWYoc3RhdGUuaWQgIT09IGFjdGlvbi5pZCkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgeyAnY29tcGxldGVkJzogIXN0YXRlLmNvbXBsZXRlZCB9KTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn07XG5cblxuY29uc3QgdG9kb3MgPSAoc3RhdGUgPSBbXSwgYWN0aW9uKSA9PiB7XG5cdHN3aXRjaChhY3Rpb24udHlwZSkge1xuXHRcdGNhc2UgJ0FERF9UT0RPJzpcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdC4uLnN0YXRlLFxuXHRcdFx0XHR0b2RvKHVuZGVmaW5lZCwgYWN0aW9uKVxuXHRcdFx0XTtcblxuXHRcdGNhc2UgJ1RPR0dMRV9UT0RPJzpcblx0XHRcdHJldHVybiBzdGF0ZS5tYXAodCA9PiB0b2RvKHQsIGFjdGlvbikpO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBzdGF0ZTtcblx0fVxufTtcblxuY29uc3QgdmlzaWJpbGl0eUZpbHRlciA9IChcblx0c3RhdGUgPSAnU0hPV19BTEwnLFxuXHRhY3Rpb25cbikgPT4ge1xuXHRzd2l0Y2goYWN0aW9uLnR5cGUpIHtcblx0XHRjYXNlICdTRVRfVklTSUJJTElUWV9GSUxURVInOlxuXHRcdFx0cmV0dXJuIGFjdGlvbi5maWx0ZXI7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG59O1xuXG5jb25zdCB0b2RvQXBwID0gY29tYmluZVJlZHVjZXJzKHtcblx0Ly8gU2hvcnQ6XG5cdHRvZG9zLFxuXHR2aXNpYmlsaXR5RmlsdGVyXG5cblx0Ly8gTG9uZzpcblx0LyogdG9kb3M6IHRvZG9zLFxuXHQvKiB2aXNpYmlsaXR5RmlsdGVyOiB2aXNpYmlsaXR5RmlsdGVyXG5cdCovXG59KTtcblxubGV0IG5leHRUb2RvSWQgPSAwO1xuY29uc3QgYWRkVG9kbyA9ICh0ZXh0KSA9PiB7XG5cdHJldHVybiB7XG5cdFx0dHlwZTogJ0FERF9UT0RPJyxcblx0XHRpZDogbmV4dFRvZG9JZCsrLFxuXHRcdHRleHRcblx0fTtcbn07XG5cbmNvbnN0IHRvZ2dsZVRvZG8gPSAoaWQpID0+IHtcblx0cmV0dXJuIHtcblx0XHR0eXBlOiAnVE9HR0xFX1RPRE8nLFxuXHRcdGlkXG5cdH07XG59O1xuXG5jb25zdCBUb2RvID0gKHtcblx0b25DbGljayxcblx0Y29tcGxldGVkLFxuXHR0ZXh0XG59KSA9PiAoXG5cdDxsaVxuXHRcdG9uQ2xpY2s9e1xuXHRcdFx0b25DbGlja1xuXHRcdH1cblx0XHRzdHlsZT17e1xuXHRcdFx0dGV4dERlY29yYXRpb246XG5cdFx0XHRcdGNvbXBsZXRlZCA/XG5cdFx0XHRcdFx0J2xpbmUtdGhyb3VnaCc6XG5cdFx0XHRcdFx0J25vbmUnXG5cdFx0fX1cblx0PlxuXHRcdHt0ZXh0fVxuXHQ8L2xpPlxuKTtcblxuY29uc3QgVG9kb0xpc3QgPSAoe1xuXHR0b2Rvcyxcblx0b25Ub2RvQ2xpY2tcbn0pID0+IChcblx0PHVsPlxuXHRcdHt0b2Rvcy5tYXAodG9kbyA9PiBcblx0XHRcdDxUb2RvXG5cdFx0XHRcdGtleT17dG9kby5pZH1cblx0XHRcdFx0ey4uLnRvZG99XG5cdFx0XHRcdG9uQ2xpY2s9eygpID0+IG9uVG9kb0NsaWNrKHRvZG8uaWQpfVxuXHRcdFx0Lz5cblx0XHQpfVxuXHQ8L3VsPlxuKTtcblxuY29uc3Qgc2V0VmlzaWJpbGl0eUZpbHRlciA9IChmaWx0ZXIpID0+IHtcblx0cmV0dXJuIHtcblx0XHR0eXBlOiAnU0VUX1ZJU0lCSUxJVFlfRklMVEVSJyxcblx0XHRmaWx0ZXJcblx0fTtcbn07XG5cbmNvbnN0IExpbmsgPSAoe1xuXHRhY3RpdmUsXG5cdGNoaWxkcmVuLFxuXHRvbkNsaWNrXG59KSA9PiB7XG5cdGlmKGFjdGl2ZSkge1xuXHRcdHJldHVybiA8c3Bhbj57Y2hpbGRyZW59PC9zcGFuPjtcblx0fVxuXHRyZXR1cm4gKFxuXHRcdDxhIGhyZWY9JyMnXG5cdFx0XHRvbkNsaWNrPXtlID0+IHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRvbkNsaWNrKCk7XG5cdFx0XHR9fVxuXHRcdD5cblx0XHRcdHtjaGlsZHJlbn1cblx0XHQ8L2E+XG5cdCk7XG59O1xuXG5jb25zdCBtYXBTdGF0ZVRvTGlua1Byb3BzID0gKFxuXHRzdGF0ZSxcblx0b3duUHJvcHNcbikgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdGFjdGl2ZTpcblx0XHRcdG93blByb3BzLmZpbHRlciA9PT0gXG5cdFx0XHRzdGF0ZS52aXNpYmlsaXR5RmlsdGVyXG5cdH07XG59O1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvTGlua1Byb3BzID0gKFxuXHRkaXNwYXRjaCxcblx0b3duUHJvcHNcbikgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdG9uQ2xpY2s6ICgpID0+IHtcblx0XHRcdGRpc3BhdGNoKFxuXHRcdFx0XHRzZXRWaXNpYmlsaXR5RmlsdGVyKG93blByb3BzLmZpbHRlcilcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufTtcblxuY29uc3QgRmlsdGVyTGluayA9IGNvbm5lY3QoXG5cdG1hcFN0YXRlVG9MaW5rUHJvcHMsXG5cdG1hcERpc3BhdGNoVG9MaW5rUHJvcHNcbikoTGluayk7XG5cbmNvbnN0IEZvb3RlciA9ICgpID0+IChcblx0PHA+XG5cdFx0U2hvdzpcblx0XHR7JyAnfVxuXHRcdDxGaWx0ZXJMaW5rXG5cdFx0XHRmaWx0ZXI9J1NIT1dfQUxMJ1xuXHRcdD5cblx0XHRcdEFsbFxuXHRcdDwvRmlsdGVyTGluaz5cblx0XHR7JywgJ31cblx0XHQ8RmlsdGVyTGlua1xuXHRcdFx0ZmlsdGVyPSdTSE9XX0FDVElWRSdcblx0XHQ+XG5cdFx0XHRBY3RpdmVcblx0XHQ8L0ZpbHRlckxpbms+XG5cdFx0eycsICd9XG5cdFx0PEZpbHRlckxpbmtcblx0XHRcdGZpbHRlcj0nU0hPV19DT01QTEVURUQnXG5cdFx0PlxuXHRcdFx0Q29tcGxldGVkXG5cdFx0PC9GaWx0ZXJMaW5rPlxuXHQ8L3A+XG4pO1xuXG5sZXQgQWRkVG9kbyA9ICh7XG5cdGRpc3BhdGNoXG59KSA9PiB7XG5cdGxldCBpbnB1dDtcblxuXHRyZXR1cm4gKFxuXHRcdDxkaXY+XG5cdFx0XHQ8aW5wdXQgcmVmPXtub2RlID0+IHtcblx0XHRcdFx0aW5wdXQgPSBub2RlO1xuXHRcdFx0fX0gLz5cblx0XHRcdDxidXR0b24gb25DbGljaz17KCkgPT4ge1xuXHRcdFx0XHRkaXNwYXRjaChhZGRUb2RvKGlucHV0LnZhbHVlKSk7XG5cdFx0XHRcdGlucHV0LnZhbHVlID0gJyc7XG5cdFx0XHR9fT5cblx0XHRcdEFkZCBUb2RvXG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQ8L2Rpdj5cblx0KTtcbn07XG5BZGRUb2RvID0gY29ubmVjdCgpKEFkZFRvZG8pO1xuXG5jb25zdCBnZXRWaXNpYmxlVG9kb3MgPSAoXG5cdHRvZG9zLFxuXHRmaWx0ZXJcbikgPT4ge1xuXHRzd2l0Y2goZmlsdGVyKSB7XG5cdFx0Y2FzZSAnU0hPV19BTEwnOlxuXHRcdFx0cmV0dXJuIHRvZG9zO1xuXG5cdFx0Y2FzZSAnU0hPV19DT01QTEVURUQnOlxuXHRcdFx0cmV0dXJuIHRvZG9zLmZpbHRlcihcblx0XHRcdFx0dCA9PiB0LmNvbXBsZXRlZFxuXHRcdFx0KTtcblxuXHRcdGNhc2UgJ1NIT1dfQUNUSVZFJzpcblx0XHRcdHJldHVybiB0b2Rvcy5maWx0ZXIoXG5cdFx0XHRcdHQgPT4gIXQuY29tcGxldGVkXG5cdFx0XHQpO1xuXHR9XG59O1xuXG5jb25zdCBtYXBTdGF0ZVRvVG9kb0xpc3RQcm9wcyA9IChcblx0c3RhdGVcbikgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdHRvZG9zOiBnZXRWaXNpYmxlVG9kb3MoXG5cdFx0XHRzdGF0ZS50b2Rvcyxcblx0XHRcdHN0YXRlLnZpc2liaWxpdHlGaWx0ZXJcblx0XHQpXG5cdH07XG59O1xuY29uc3QgbWFwRGlzcGF0Y2hUb1RvZG9MaXN0UHJvcHMgPSAoXG5cdGRpc3BhdGNoXG4pID0+IHtcblx0cmV0dXJuIHtcblx0XHRvblRvZG9DbGljazogKGlkKSA9PiB7IFxuXHRcdFx0ZGlzcGF0Y2godG9nZ2xlVG9kbyhpZCkpO1xuXHRcdH1cblx0fTtcbn07XG5jb25zdCBWaXNpYmxlVG9kb0xpc3QgPSBjb25uZWN0KFxuXHRtYXBTdGF0ZVRvVG9kb0xpc3RQcm9wcyxcblx0bWFwRGlzcGF0Y2hUb1RvZG9MaXN0UHJvcHNcbikoVG9kb0xpc3QpO1xuXG5jb25zdCBUb2RvQXBwID0gKCkgPT4gKFx0XG5cdDxkaXY+XG5cdFx0PEFkZFRvZG8gLz5cblx0XHQ8VmlzaWJsZVRvZG9MaXN0IC8+XG5cdFx0PEZvb3RlciAvPlx0XHRcblx0PC9kaXY+XG4pO1xuXG5jb25zdCB7IFByb3ZpZGVyIH0gPSBSZWFjdFJlZHV4O1xuLy8gRVM2ICB2aWEgYmFiZWw6IGltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuLy8gRVM1OiB2YXIgUHJvdmlkZXIgPSByZXF1aXJlKCdyZWFjdC1yZWR1eCcpLlByb3ZpZGVyO1xuXG5jb25zdCB7IGNyZWF0ZVN0b3JlIH0gPSBSZWR1eDtcblxuUmVhY3RET00ucmVuZGVyKFxuXHQ8UHJvdmlkZXIgc3RvcmU9e2NyZWF0ZVN0b3JlKHRvZG9BcHApfT5cblx0XHQ8VG9kb0FwcCAvPlxuXHQ8L1Byb3ZpZGVyPixcblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKVxuKTtcbiJdfQ==
