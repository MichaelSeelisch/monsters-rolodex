(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = function deepFreeze (o) {
  Object.freeze(o);

  var oIsFunction = typeof o === "function";
  var hasOwnProp = Object.prototype.hasOwnProperty;

  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (hasOwnProp.call(o, prop)
    && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true )
    && o[prop] !== null
    && (typeof o[prop] === "object" || typeof o[prop] === "function")
    && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  
  return o;
};

},{}],2:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _isRegexp = require('is-regexp');

var _isRegexp2 = _interopRequireDefault(_isRegexp);

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _SpyUtils = require('./SpyUtils');

var _TestUtils = require('./TestUtils');

/**
 * An Expectation is a wrapper around an assertion that allows it to be written
 * in a more natural style, without the need to remember the order of arguments.
 * This helps prevent you from making mistakes when writing tests.
 */

var Expectation = (function () {
  function Expectation(actual) {
    _classCallCheck(this, Expectation);

    this.actual = actual;

    if (_TestUtils.isFunction(actual)) {
      this.context = null;
      this.args = [];
    }
  }

  Expectation.prototype.toExist = function toExist(message) {
    _assert2['default'](this.actual, message || 'Expected %s to exist', this.actual);

    return this;
  };

  Expectation.prototype.toNotExist = function toNotExist(message) {
    _assert2['default'](!this.actual, message || 'Expected %s to not exist', this.actual);

    return this;
  };

  Expectation.prototype.toBe = function toBe(value, message) {
    _assert2['default'](this.actual === value, message || 'Expected %s to be %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toNotBe = function toNotBe(value, message) {
    _assert2['default'](this.actual !== value, message || 'Expected %s to not be %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toEqual = function toEqual(value, message) {
    try {
      _assert2['default'](_deepEqual2['default'](this.actual, value), message || 'Expected %s to equal %s', this.actual, value);
    } catch (e) {
      // These attributes are consumed by Mocha to produce a diff output.
      e.showDiff = true;
      e.actual = this.actual;
      e.expected = value;
      throw e;
    }

    return this;
  };

  Expectation.prototype.toNotEqual = function toNotEqual(value, message) {
    _assert2['default'](!_deepEqual2['default'](this.actual, value), message || 'Expected %s to not equal %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toThrow = function toThrow(value, message) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).toThrow() must be a function, %s was given', this.actual);

    _assert2['default'](_TestUtils.functionThrows(this.actual, this.context, this.args, value), message || 'Expected %s to throw %s', this.actual, value || 'an error');

    return this;
  };

  Expectation.prototype.toNotThrow = function toNotThrow(value, message) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).toNotThrow() must be a function, %s was given', this.actual);

    _assert2['default'](!_TestUtils.functionThrows(this.actual, this.context, this.args, value), message || 'Expected %s to not throw %s', this.actual, value || 'an error');

    return this;
  };

  Expectation.prototype.toBeA = function toBeA(value, message) {
    _assert2['default'](_TestUtils.isFunction(value) || typeof value === 'string', 'The "value" argument in toBeA(value) must be a function or a string');

    _assert2['default'](_TestUtils.isA(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toNotBeA = function toNotBeA(value, message) {
    _assert2['default'](_TestUtils.isFunction(value) || typeof value === 'string', 'The "value" argument in toNotBeA(value) must be a function or a string');

    _assert2['default'](!_TestUtils.isA(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toMatch = function toMatch(pattern, message) {
    _assert2['default'](typeof this.actual === 'string', 'The "actual" argument in expect(actual).toMatch() must be a string');

    _assert2['default'](_isRegexp2['default'](pattern), 'The "value" argument in toMatch(value) must be a RegExp');

    _assert2['default'](pattern.test(this.actual), message || 'Expected %s to match %s', this.actual, pattern);

    return this;
  };

  Expectation.prototype.toNotMatch = function toNotMatch(pattern, message) {
    _assert2['default'](typeof this.actual === 'string', 'The "actual" argument in expect(actual).toNotMatch() must be a string');

    _assert2['default'](_isRegexp2['default'](pattern), 'The "value" argument in toNotMatch(value) must be a RegExp');

    _assert2['default'](!pattern.test(this.actual), message || 'Expected %s to not match %s', this.actual, pattern);

    return this;
  };

  Expectation.prototype.toBeLessThan = function toBeLessThan(value, message) {
    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThan() must be a number');

    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeLessThan(value) must be a number');

    _assert2['default'](this.actual < value, message || 'Expected %s to be less than %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toBeGreaterThan = function toBeGreaterThan(value, message) {
    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThan() must be a number');

    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeGreaterThan(value) must be a number');

    _assert2['default'](this.actual > value, message || 'Expected %s to be greater than %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toInclude = function toInclude(value, comparator, message) {
    _assert2['default'](_TestUtils.isArray(this.actual) || typeof this.actual === 'string', 'The "actual" argument in expect(actual).toInclude() must be an array or a string');

    if (typeof comparator === 'string') {
      message = comparator;
      comparator = null;
    }

    message = message || 'Expected %s to include %s';

    if (_TestUtils.isArray(this.actual)) {
      _assert2['default'](_TestUtils.arrayContains(this.actual, value, comparator), message, this.actual, value);
    } else {
      _assert2['default'](_TestUtils.stringContains(this.actual, value), message, this.actual, value);
    }

    return this;
  };

  Expectation.prototype.toExclude = function toExclude(value, comparator, message) {
    _assert2['default'](_TestUtils.isArray(this.actual) || typeof this.actual === 'string', 'The "actual" argument in expect(actual).toExclude() must be an array or a string');

    if (typeof comparator === 'string') {
      message = comparator;
      comparator = null;
    }

    message = message || 'Expected %s to exclude %s';

    if (_TestUtils.isArray(this.actual)) {
      _assert2['default'](!_TestUtils.arrayContains(this.actual, value, comparator), message, this.actual, value);
    } else {
      _assert2['default'](!_TestUtils.stringContains(this.actual, value), message, this.actual, value);
    }

    return this;
  };

  Expectation.prototype.toHaveBeenCalled = function toHaveBeenCalled(message) {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toHaveBeenCalled() must be a spy');

    _assert2['default'](spy.calls.length > 0, message || 'spy was not called');

    return this;
  };

  Expectation.prototype.toHaveBeenCalledWith = function toHaveBeenCalledWith() {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toHaveBeenCalledWith() must be a spy');

    var expectedArgs = Array.prototype.slice.call(arguments, 0);

    _assert2['default'](spy.calls.some(function (call) {
      return _deepEqual2['default'](call.arguments, expectedArgs);
    }), 'spy was never called with %s', expectedArgs);

    return this;
  };

  Expectation.prototype.toNotHaveBeenCalled = function toNotHaveBeenCalled(message) {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toNotHaveBeenCalled() must be a spy');

    _assert2['default'](spy.calls.length === 0, message || 'spy was not supposed to be called');

    return this;
  };

  Expectation.prototype.withContext = function withContext(context) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).withContext() must be a function');

    this.context = context;

    return this;
  };

  Expectation.prototype.withArgs = function withArgs() {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).withArgs() must be a function');

    if (arguments.length) this.args = this.args.concat(Array.prototype.slice.call(arguments, 0));

    return this;
  };

  return Expectation;
})();

var aliases = {
  toBeAn: 'toBeA',
  toNotBeAn: 'toNotBeA',
  toBeTruthy: 'toExist',
  toBeFalsy: 'toNotExist',
  toBeFewerThan: 'toBeLessThan',
  toBeMoreThan: 'toBeGreaterThan',
  toContain: 'toInclude',
  toNotContain: 'toExclude'
};

for (var alias in aliases) {
  Expectation.prototype[alias] = Expectation.prototype[aliases[alias]];
}exports['default'] = Expectation;
module.exports = exports['default'];
},{"./SpyUtils":3,"./TestUtils":4,"./assert":5,"deep-equal":8,"is-regexp":11}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.createSpy = createSpy;
exports.spyOn = spyOn;
exports.isSpy = isSpy;
exports.restoreSpies = restoreSpies;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _TestUtils = require('./TestUtils');

function noop() {}

var spies = [];

function createSpy(fn) {
  var restore = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];

  if (fn == null) fn = noop;

  _assert2['default'](_TestUtils.isFunction(fn), 'createSpy needs a function');

  var targetFn = undefined,
      thrownValue = undefined,
      returnValue = undefined;

  var spy = function spy() {
    spy.calls.push({
      context: this,
      arguments: Array.prototype.slice.call(arguments, 0)
    });

    if (targetFn) return targetFn.apply(this, arguments);

    if (thrownValue) throw thrownValue;

    return returnValue;
  };

  spy.calls = [];

  spy.andCall = function (fn) {
    targetFn = fn;
    return spy;
  };

  spy.andCallThrough = function () {
    return spy.andCall(fn);
  };

  spy.andThrow = function (object) {
    thrownValue = object;
    return spy;
  };

  spy.andReturn = function (value) {
    returnValue = value;
    return spy;
  };

  spy.getLastCall = function () {
    return spy.calls[spy.calls.length - 1];
  };

  spy.restore = spy.destroy = restore;

  spy.__isSpy = true;

  spies.push(spy);

  return spy;
}

function spyOn(object, methodName) {
  var original = object[methodName];

  if (!isSpy(original)) {
    _assert2['default'](_TestUtils.isFunction(original), 'Cannot spyOn the %s property; it is not a function', methodName);

    object[methodName] = createSpy(original, function () {
      object[methodName] = original;
    });
  }

  return object[methodName];
}

function isSpy(object) {
  return object && object.__isSpy === true;
}

function restoreSpies() {
  for (var i = spies.length - 1; i >= 0; i--) {
    spies[i].restore();
  }spies = [];
}
},{"./TestUtils":4,"./assert":5}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.functionThrows = functionThrows;
exports.arrayContains = arrayContains;
exports.stringContains = stringContains;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isA = isA;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _isRegexp = require('is-regexp');

var _isRegexp2 = _interopRequireDefault(_isRegexp);

/**
 * Returns true if the given function throws the given value
 * when invoked. The value may be:
 *
 * - undefined, to merely assert there was a throw
 * - a constructor function, for comparing using instanceof
 * - a regular expression, to compare with the error message
 * - a string, to find in the error message
 */

function functionThrows(fn, context, args, value) {
  try {
    fn.apply(context, args);
  } catch (error) {
    if (value == null) return true;

    if (isFunction(value) && error instanceof value) return true;

    var message = error.message || error;

    if (typeof message === 'string') {
      if (_isRegexp2['default'](value) && value.test(error.message)) return true;

      if (typeof value === 'string' && message.indexOf(value) !== -1) return true;
    }
  }

  return false;
}

/**
 * Returns true if the given array contains the value, false
 * otherwise. The comparator function must return false to
 * indicate a non-match.
 */

function arrayContains(array, value, comparator) {
  if (comparator == null) comparator = _deepEqual2['default'];

  return array.some(function (item) {
    return comparator(item, value) !== false;
  });
}

/**
 * Returns true if the given string contains the value, false otherwise.
 */

function stringContains(string, value) {
  return string.indexOf(value) !== -1;
}

/**
 * Returns true if the given object is an array.
 */

function isArray(object) {
  return Array.isArray(object);
}

/**
 * Returns true if the given object is a function.
 */

function isFunction(object) {
  return typeof object === 'function';
}

/**
 * Returns true if the given object is an instanceof value
 * or its typeof is the given value.
 */

function isA(object, value) {
  if (isFunction(value)) return object instanceof value;

  if (value === 'array') return Array.isArray(object);

  return typeof object === value;
}
},{"deep-equal":8,"is-regexp":11}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _objectInspect = require('object-inspect');

var _objectInspect2 = _interopRequireDefault(_objectInspect);

function assert(condition, messageFormat) {
  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    extraArgs[_key - 2] = arguments[_key];
  }

  if (condition) return;

  var index = 0;

  throw new Error(messageFormat.replace(/%s/g, function () {
    return _objectInspect2['default'](extraArgs[index++]);
  }));
}

exports['default'] = assert;
module.exports = exports['default'];
},{"object-inspect":12}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Expectation = require('./Expectation');

var _Expectation2 = _interopRequireDefault(_Expectation);

var Extensions = [];

function extend(extension) {
  if (Extensions.indexOf(extension) === -1) {
    Extensions.push(extension);

    for (var p in extension) {
      if (extension.hasOwnProperty(p)) _Expectation2['default'].prototype[p] = extension[p];
    }
  }
}

exports['default'] = extend;
module.exports = exports['default'];
},{"./Expectation":2}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Expectation = require('./Expectation');

var _Expectation2 = _interopRequireDefault(_Expectation);

var _SpyUtils = require('./SpyUtils');

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _extend = require('./extend');

var _extend2 = _interopRequireDefault(_extend);

function expect(actual) {
  return new _Expectation2['default'](actual);
}

expect.createSpy = _SpyUtils.createSpy;
expect.spyOn = _SpyUtils.spyOn;
expect.isSpy = _SpyUtils.isSpy;
expect.restoreSpies = _SpyUtils.restoreSpies;
expect.assert = _assert2['default'];
expect.extend = _extend2['default'];

exports['default'] = expect;
module.exports = exports['default'];
},{"./Expectation":2,"./SpyUtils":3,"./assert":5,"./extend":6}],8:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":9,"./lib/keys.js":10}],9:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],10:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],11:[function(require,module,exports){
'use strict';
module.exports = function (re) {
	return Object.prototype.toString.call(re) === '[object RegExp]';
};

},{}],12:[function(require,module,exports){
module.exports = function inspect_ (obj, opts, depth, seen) {
    if (!opts) opts = {};
    
    var maxDepth = opts.depth === undefined ? 5 : opts.depth;
    if (depth === undefined) depth = 0;
    if (depth >= maxDepth && maxDepth > 0
    && obj && typeof obj === 'object') {
        return '[Object]';
    }
    
    if (seen === undefined) seen = [];
    else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }
    
    function inspect (value, from) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        return inspect_(value, opts, depth + 1, seen);
    }
    
    if (typeof obj === 'string') {
        return inspectString(obj);
    }
    else if (typeof obj === 'function') {
        var name = nameOf(obj);
        return '[Function' + (name ? ': ' + name : '') + ']';
    }
    else if (obj === null) {
        return 'null';
    }
    else if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;
    }
    else if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '="' + quote(attrs[i].value) + '"';
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) s += '...';
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    else if (isArray(obj)) {
        if (obj.length === 0) return '[]';
        var xs = Array(obj.length);
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    else if (isError(obj)) {
        var parts = [];
        for (var key in obj) {
            if (!has(obj, key)) continue;
            
            if (/[^\w$]/.test(key)) {
                parts.push(inspect(key) + ': ' + inspect(obj[key]));
            }
            else {
                parts.push(key + ': ' + inspect(obj[key]));
            }
        }
        if (parts.length === 0) return '[' + obj + ']';
        return '{ [' + obj + '] ' + parts.join(', ') + ' }';
    }
    else if (typeof obj === 'object' && typeof obj.inspect === 'function') {
        return obj.inspect();
    }
    else if (typeof obj === 'object' && !isDate(obj) && !isRegExp(obj)) {
        var xs = [], keys = [];
        for (var key in obj) {
            if (has(obj, key)) keys.push(key);
        }
        keys.sort();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (/[^\w$]/.test(key)) {
                xs.push(inspect(key) + ': ' + inspect(obj[key], obj));
            }
            else xs.push(key + ': ' + inspect(obj[key], obj));
        }
        if (xs.length === 0) return '{}';
        return '{ ' + xs.join(', ') + ' }';
    }
    else return String(obj);
};

function quote (s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray (obj) { return toStr(obj) === '[object Array]' }
function isDate (obj) { return toStr(obj) === '[object Date]' }
function isRegExp (obj) { return toStr(obj) === '[object RegExp]' }
function isError (obj) { return toStr(obj) === '[object Error]' }
function isSymbol (obj) { return toStr(obj) === '[object Symbol]' }

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has (obj, key) {
    return hasOwn.call(obj, key);
}

function toStr (obj) {
    return Object.prototype.toString.call(obj);
}

function nameOf (f) {
    if (f.name) return f.name;
    var m = f.toString().match(/^function\s*([\w$]+)/);
    if (m) return m[1];
}

function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
}

function isElement (x) {
    if (!x || typeof x !== 'object') return false;
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string'
        && typeof x.getAttribute === 'function'
    ;
}

function inspectString (str) {
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return "'" + s + "'";
    
    function lowbyte (c) {
        var n = c.charCodeAt(0);
        var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
        if (x) return '\\' + x;
        return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
    }
}

},{}],13:[function(require,module,exports){
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _expect = require('expect');

var _expect2 = _interopRequireDefault(_expect);

var _deepFreezeStrict = require('deep-freeze-strict');

var _deepFreezeStrict2 = _interopRequireDefault(_deepFreezeStrict);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } // Using an ES6 transpiler, like babel

var todo = function todo(state, action) {
	switch (action.type) {
		case 'ADD_TODO':
			return {
				id: action.id,
				text: action.text,
				completed: false
			};

		case 'TOGGLE_TODO':
			if (state.id !== action.id) {
				return state;
			}

			return Object.assign({}, state, { 'completed': !state.completed });

		default:
			return state;
	}
};

var todos = function todos() {
	var state = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	var action = arguments[1];

	switch (action.type) {
		case 'ADD_TODO':
			return [].concat(_toConsumableArray(state), [todo(undefined, action)]);

		case 'TOGGLE_TODO':
			return state.map(function (t) {
				return todo(t, action);
			});

		default:
			return state;
	}
};

var visibilityFilter = function visibilityFilter() {
	var state = arguments.length <= 0 || arguments[0] === undefined ? 'SHOW_ALL' : arguments[0];
	var action = arguments[1];

	switch (action.type) {
		case 'SET_VISIBILITY_FILTER':
			return action.filter;

		default:
			return state;
	}
};

var _Redux = Redux;
var combineReducers = _Redux.combineReducers;

var todoApp = combineReducers({
	// Short:
	todos: todos,
	visibilityFilter: visibilityFilter

	// Long:
	/* todos: todos,
 /* visibilityFilter: visibilityFilter
 */
});

var _Redux2 = Redux;
var createStore = _Redux2.createStore;

var store = createStore(todoApp);

var _React = React;
var Component = _React.Component;

var Todo = function Todo(_ref) {
	var onClick = _ref.onClick;
	var completed = _ref.completed;
	var text = _ref.text;
	return React.createElement(
		'li',
		{
			onClick: onClick,
			style: {
				textDecoration: completed ? 'line-through' : 'none'
			}
		},
		text
	);
};

var TodoList = function TodoList(_ref2) {
	var todos = _ref2.todos;
	var onTodoClick = _ref2.onTodoClick;
	return React.createElement(
		'ul',
		null,
		todos.map(function (todo) {
			return React.createElement(Todo, _extends({
				key: todo.id
			}, todo, {
				onClick: function onClick() {
					return onTodoClick(todo.id);
				}
			}));
		})
	);
};

var Link = function Link(_ref3) {
	var active = _ref3.active;
	var children = _ref3.children;
	var _onClick = _ref3.onClick;

	if (active) {
		return React.createElement(
			'span',
			null,
			children
		);
	}
	return React.createElement(
		'a',
		{ href: '#',
			onClick: function onClick(e) {
				e.preventDefault();
				_onClick();
			}
		},
		children
	);
};

var FilterLink = (function (_Component) {
	_inherits(FilterLink, _Component);

	function FilterLink() {
		_classCallCheck(this, FilterLink);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(FilterLink).apply(this, arguments));
	}

	_createClass(FilterLink, [{
		key: 'componentdidMount',
		value: function componentdidMount() {
			var _this2 = this;

			this.unsubscribe = store.subscribe(function () {
				return _this2.forceUpdate();
			});
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.unsubscribe();
		}
	}, {
		key: 'render',
		value: function render() {
			var props = this.props;
			var state = store.getState();

			return React.createElement(
				Link,
				{
					active: props.filter === state.visibilityFilter,
					onClick: function onClick() {
						return store.dispatch({
							type: 'SET_VISIBILITY_FILTER',
							filter: props.filter
						});
					}
				},
				props.children
			);
		}
	}]);

	return FilterLink;
})(Component);

;

var Footer = function Footer() {
	return React.createElement(
		'p',
		null,
		'Show:',
		' ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_ALL'
			},
			'All'
		),
		', ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_ACTIVE'
			},
			'Active'
		),
		', ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_COMPLETED'
			},
			'Completed'
		)
	);
};

var AddTodo = function AddTodo() {
	var input = undefined;

	return React.createElement(
		'div',
		null,
		React.createElement('input', { ref: function ref(node) {
				input = node;
			} }),
		React.createElement(
			'button',
			{ onClick: function onClick() {
					store.dispatch({
						type: 'ADD_TODO',
						id: nextTodoId++,
						text: input.value
					});
					input.value = '';
				} },
			'Add Todo'
		)
	);
};

var getVisibleTodos = function getVisibleTodos(todos, filter) {
	switch (filter) {
		case 'SHOW_ALL':
			return todos;

		case 'SHOW_COMPLETED':
			return todos.filter(function (t) {
				return t.completed;
			});

		case 'SHOW_ACTIVE':
			return todos.filter(function (t) {
				return !t.completed;
			});
	}
};

var VisibleTodoList = (function (_Component2) {
	_inherits(VisibleTodoList, _Component2);

	function VisibleTodoList() {
		_classCallCheck(this, VisibleTodoList);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(VisibleTodoList).apply(this, arguments));
	}

	_createClass(VisibleTodoList, [{
		key: 'componentdidMount',
		value: function componentdidMount() {
			var _this4 = this;

			this.unsubscribe = store.subscribe(function () {
				return _this4.forceUpdate();
			});
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.unsubscribe();
		}
	}, {
		key: 'render',
		value: function render() {
			var props = this.props;
			var state = store.getState();

			return React.createElement(TodoList, {
				todos: getVisibleTodos(state.todos, state.visibilityFilter),
				onTodoClick: function onTodoClick(id) {
					return store.dispatch({
						type: 'TOGGLE_TODO',
						id: id
					});
				} });
		}
	}]);

	return VisibleTodoList;
})(Component);

;

var nextTodoId = 0;

var TodoApp = function TodoApp() {
	return React.createElement(
		'div',
		null,
		React.createElement(AddTodo, null),
		React.createElement(VisibleTodoList, null),
		React.createElement(Footer, null)
	);
};

var render = function render() {
	ReactDOM.render(React.createElement(TodoApp, null), document.getElementById('root'));
};

store.subscribe(render);
render();

},{"deep-freeze-strict":1,"expect":7}]},{},[13])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZGVlcC1mcmVlemUtc3RyaWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V4cGVjdC9saWIvRXhwZWN0YXRpb24uanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L2xpYi9TcHlVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL1Rlc3RVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V4cGVjdC9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L25vZGVfbW9kdWxlcy9pcy1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsInNyYy8xM19FeHRyYWN0aW5nX0NvbnRhaW5lcl9Db21wb25lbnRzXyhWaXNpYmxlVG9kb0xpc3QsX0FkZFRvZG8pL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RSxhQUFhO0FBQ25CLFFBQUUsRUFBRixFQUFFO01BQ0YsQ0FBQztLQUFBLEFBQ0YsR0FBRyxDQUNKO0dBQ0Y7OztRQTlCSSxlQUFlO0dBQVMsU0FBUzs7QUErQnRDLENBQUM7O0FBRUYsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDOztBQUVuQixJQUFNLE9BQU8sR0FBRyxTQUFWLE9BQU87UUFDWjs7O0VBQ0Msb0JBQUMsT0FBTyxPQUFHO0VBQ1gsb0JBQUMsZUFBZSxPQUFHO0VBQ25CLG9CQUFDLE1BQU0sT0FBRztFQUNMO0NBQ04sQ0FBQzs7QUFFRixJQUFNLE1BQU0sR0FBRyxTQUFULE1BQU0sR0FBUztBQUNwQixTQUFRLENBQUMsTUFBTSxDQUNkLG9CQUFDLE9BQU8sT0FBRyxFQUNYLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQy9CLENBQUM7Q0FDRixDQUFDOztBQUVGLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDeEIsTUFBTSxFQUFFLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWVwRnJlZXplIChvKSB7XG4gIE9iamVjdC5mcmVlemUobyk7XG5cbiAgdmFyIG9Jc0Z1bmN0aW9uID0gdHlwZW9mIG8gPT09IFwiZnVuY3Rpb25cIjtcbiAgdmFyIGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG8pLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZiAoaGFzT3duUHJvcC5jYWxsKG8sIHByb3ApXG4gICAgJiYgKG9Jc0Z1bmN0aW9uID8gcHJvcCAhPT0gJ2NhbGxlcicgJiYgcHJvcCAhPT0gJ2NhbGxlZScgJiYgcHJvcCAhPT0gJ2FyZ3VtZW50cycgOiB0cnVlIClcbiAgICAmJiBvW3Byb3BdICE9PSBudWxsXG4gICAgJiYgKHR5cGVvZiBvW3Byb3BdID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvW3Byb3BdID09PSBcImZ1bmN0aW9uXCIpXG4gICAgJiYgIU9iamVjdC5pc0Zyb3plbihvW3Byb3BdKSkge1xuICAgICAgZGVlcEZyZWV6ZShvW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIG87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX2RlZXBFcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcblxudmFyIF9kZWVwRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcEVxdWFsKTtcblxudmFyIF9pc1JlZ2V4cCA9IHJlcXVpcmUoJ2lzLXJlZ2V4cCcpO1xuXG52YXIgX2lzUmVnZXhwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUmVnZXhwKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuXG52YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnQpO1xuXG52YXIgX1NweVV0aWxzID0gcmVxdWlyZSgnLi9TcHlVdGlscycpO1xuXG52YXIgX1Rlc3RVdGlscyA9IHJlcXVpcmUoJy4vVGVzdFV0aWxzJyk7XG5cbi8qKlxuICogQW4gRXhwZWN0YXRpb24gaXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBhc3NlcnRpb24gdGhhdCBhbGxvd3MgaXQgdG8gYmUgd3JpdHRlblxuICogaW4gYSBtb3JlIG5hdHVyYWwgc3R5bGUsIHdpdGhvdXQgdGhlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIG9yZGVyIG9mIGFyZ3VtZW50cy5cbiAqIFRoaXMgaGVscHMgcHJldmVudCB5b3UgZnJvbSBtYWtpbmcgbWlzdGFrZXMgd2hlbiB3cml0aW5nIHRlc3RzLlxuICovXG5cbnZhciBFeHBlY3RhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cGVjdGF0aW9uKGFjdHVhbCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHBlY3RhdGlvbik7XG5cbiAgICB0aGlzLmFjdHVhbCA9IGFjdHVhbDtcblxuICAgIGlmIChfVGVzdFV0aWxzLmlzRnVuY3Rpb24oYWN0dWFsKSkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuYXJncyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0V4aXN0ID0gZnVuY3Rpb24gdG9FeGlzdChtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0aGlzLmFjdHVhbCwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gZXhpc3QnLCB0aGlzLmFjdHVhbCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9Ob3RFeGlzdCA9IGZ1bmN0aW9uIHRvTm90RXhpc3QobWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oIXRoaXMuYWN0dWFsLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBub3QgZXhpc3QnLCB0aGlzLmFjdHVhbCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9CZSA9IGZ1bmN0aW9uIHRvQmUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHRoaXMuYWN0dWFsID09PSB2YWx1ZSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gYmUgJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvTm90QmUgPSBmdW5jdGlvbiB0b05vdEJlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0aGlzLmFjdHVhbCAhPT0gdmFsdWUsIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIG5vdCBiZSAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9FcXVhbCA9IGZ1bmN0aW9uIHRvRXF1YWwodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfZGVlcEVxdWFsMlsnZGVmYXVsdCddKHRoaXMuYWN0dWFsLCB2YWx1ZSksIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGVxdWFsICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFyZSBjb25zdW1lZCBieSBNb2NoYSB0byBwcm9kdWNlIGEgZGlmZiBvdXRwdXQuXG4gICAgICBlLnNob3dEaWZmID0gdHJ1ZTtcbiAgICAgIGUuYWN0dWFsID0gdGhpcy5hY3R1YWw7XG4gICAgICBlLmV4cGVjdGVkID0gdmFsdWU7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b05vdEVxdWFsID0gZnVuY3Rpb24gdG9Ob3RFcXVhbCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oIV9kZWVwRXF1YWwyWydkZWZhdWx0J10odGhpcy5hY3R1YWwsIHZhbHVlKSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gbm90IGVxdWFsICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b1Rocm93ID0gZnVuY3Rpb24gdG9UaHJvdyh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKHRoaXMuYWN0dWFsKSwgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvVGhyb3coKSBtdXN0IGJlIGEgZnVuY3Rpb24sICVzIHdhcyBnaXZlbicsIHRoaXMuYWN0dWFsKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5mdW5jdGlvblRocm93cyh0aGlzLmFjdHVhbCwgdGhpcy5jb250ZXh0LCB0aGlzLmFyZ3MsIHZhbHVlKSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gdGhyb3cgJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUgfHwgJ2FuIGVycm9yJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9Ob3RUaHJvdyA9IGZ1bmN0aW9uIHRvTm90VGhyb3codmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNGdW5jdGlvbih0aGlzLmFjdHVhbCksICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b05vdFRocm93KCkgbXVzdCBiZSBhIGZ1bmN0aW9uLCAlcyB3YXMgZ2l2ZW4nLCB0aGlzLmFjdHVhbCk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKCFfVGVzdFV0aWxzLmZ1bmN0aW9uVGhyb3dzKHRoaXMuYWN0dWFsLCB0aGlzLmNvbnRleHQsIHRoaXMuYXJncywgdmFsdWUpLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBub3QgdGhyb3cgJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUgfHwgJ2FuIGVycm9yJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9CZUEgPSBmdW5jdGlvbiB0b0JlQSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBpbiB0b0JlQSh2YWx1ZSkgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNBKHRoaXMuYWN0dWFsLCB2YWx1ZSksIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGJlIGEgJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvTm90QmVBID0gZnVuY3Rpb24gdG9Ob3RCZUEodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgaW4gdG9Ob3RCZUEodmFsdWUpIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSghX1Rlc3RVdGlscy5pc0EodGhpcy5hY3R1YWwsIHZhbHVlKSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gYmUgYSAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9NYXRjaCA9IGZ1bmN0aW9uIHRvTWF0Y2gocGF0dGVybiwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odHlwZW9mIHRoaXMuYWN0dWFsID09PSAnc3RyaW5nJywgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvTWF0Y2goKSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9pc1JlZ2V4cDJbJ2RlZmF1bHQnXShwYXR0ZXJuKSwgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgaW4gdG9NYXRjaCh2YWx1ZSkgbXVzdCBiZSBhIFJlZ0V4cCcpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShwYXR0ZXJuLnRlc3QodGhpcy5hY3R1YWwpLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBtYXRjaCAlcycsIHRoaXMuYWN0dWFsLCBwYXR0ZXJuKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b05vdE1hdGNoID0gZnVuY3Rpb24gdG9Ob3RNYXRjaChwYXR0ZXJuLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0eXBlb2YgdGhpcy5hY3R1YWwgPT09ICdzdHJpbmcnLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9Ob3RNYXRjaCgpIG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX2lzUmVnZXhwMlsnZGVmYXVsdCddKHBhdHRlcm4pLCAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBpbiB0b05vdE1hdGNoKHZhbHVlKSBtdXN0IGJlIGEgUmVnRXhwJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKCFwYXR0ZXJuLnRlc3QodGhpcy5hY3R1YWwpLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBub3QgbWF0Y2ggJXMnLCB0aGlzLmFjdHVhbCwgcGF0dGVybik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9CZUxlc3NUaGFuID0gZnVuY3Rpb24gdG9CZUxlc3NUaGFuKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0eXBlb2YgdGhpcy5hY3R1YWwgPT09ICdudW1iZXInLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9CZUxlc3NUaGFuKCkgbXVzdCBiZSBhIG51bWJlcicpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBpbiB0b0JlTGVzc1RoYW4odmFsdWUpIG11c3QgYmUgYSBudW1iZXInKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odGhpcy5hY3R1YWwgPCB2YWx1ZSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gYmUgbGVzcyB0aGFuICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0JlR3JlYXRlclRoYW4gPSBmdW5jdGlvbiB0b0JlR3JlYXRlclRoYW4odmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHR5cGVvZiB0aGlzLmFjdHVhbCA9PT0gJ251bWJlcicsICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b0JlR3JlYXRlclRoYW4oKSBtdXN0IGJlIGEgbnVtYmVyJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IGluIHRvQmVHcmVhdGVyVGhhbih2YWx1ZSkgbXVzdCBiZSBhIG51bWJlcicpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0aGlzLmFjdHVhbCA+IHZhbHVlLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBiZSBncmVhdGVyIHRoYW4gJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvSW5jbHVkZSA9IGZ1bmN0aW9uIHRvSW5jbHVkZSh2YWx1ZSwgY29tcGFyYXRvciwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0FycmF5KHRoaXMuYWN0dWFsKSB8fCB0eXBlb2YgdGhpcy5hY3R1YWwgPT09ICdzdHJpbmcnLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9JbmNsdWRlKCkgbXVzdCBiZSBhbiBhcnJheSBvciBhIHN0cmluZycpO1xuXG4gICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgbWVzc2FnZSA9IGNvbXBhcmF0b3I7XG4gICAgICBjb21wYXJhdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gaW5jbHVkZSAlcyc7XG5cbiAgICBpZiAoX1Rlc3RVdGlscy5pc0FycmF5KHRoaXMuYWN0dWFsKSkge1xuICAgICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmFycmF5Q29udGFpbnModGhpcy5hY3R1YWwsIHZhbHVlLCBjb21wYXJhdG9yKSwgbWVzc2FnZSwgdGhpcy5hY3R1YWwsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLnN0cmluZ0NvbnRhaW5zKHRoaXMuYWN0dWFsLCB2YWx1ZSksIG1lc3NhZ2UsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvRXhjbHVkZSA9IGZ1bmN0aW9uIHRvRXhjbHVkZSh2YWx1ZSwgY29tcGFyYXRvciwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0FycmF5KHRoaXMuYWN0dWFsKSB8fCB0eXBlb2YgdGhpcy5hY3R1YWwgPT09ICdzdHJpbmcnLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9FeGNsdWRlKCkgbXVzdCBiZSBhbiBhcnJheSBvciBhIHN0cmluZycpO1xuXG4gICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgbWVzc2FnZSA9IGNvbXBhcmF0b3I7XG4gICAgICBjb21wYXJhdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gZXhjbHVkZSAlcyc7XG5cbiAgICBpZiAoX1Rlc3RVdGlscy5pc0FycmF5KHRoaXMuYWN0dWFsKSkge1xuICAgICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSghX1Rlc3RVdGlscy5hcnJheUNvbnRhaW5zKHRoaXMuYWN0dWFsLCB2YWx1ZSwgY29tcGFyYXRvciksIG1lc3NhZ2UsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hc3NlcnQyWydkZWZhdWx0J10oIV9UZXN0VXRpbHMuc3RyaW5nQ29udGFpbnModGhpcy5hY3R1YWwsIHZhbHVlKSwgbWVzc2FnZSwgdGhpcy5hY3R1YWwsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9IYXZlQmVlbkNhbGxlZCA9IGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWQobWVzc2FnZSkge1xuICAgIHZhciBzcHkgPSB0aGlzLmFjdHVhbDtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1NweVV0aWxzLmlzU3B5KHNweSksICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b0hhdmVCZWVuQ2FsbGVkKCkgbXVzdCBiZSBhIHNweScpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShzcHkuY2FsbHMubGVuZ3RoID4gMCwgbWVzc2FnZSB8fCAnc3B5IHdhcyBub3QgY2FsbGVkJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9IYXZlQmVlbkNhbGxlZFdpdGggPSBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkV2l0aCgpIHtcbiAgICB2YXIgc3B5ID0gdGhpcy5hY3R1YWw7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9TcHlVdGlscy5pc1NweShzcHkpLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoKSBtdXN0IGJlIGEgc3B5Jyk7XG5cbiAgICB2YXIgZXhwZWN0ZWRBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oc3B5LmNhbGxzLnNvbWUoZnVuY3Rpb24gKGNhbGwpIHtcbiAgICAgIHJldHVybiBfZGVlcEVxdWFsMlsnZGVmYXVsdCddKGNhbGwuYXJndW1lbnRzLCBleHBlY3RlZEFyZ3MpO1xuICAgIH0pLCAnc3B5IHdhcyBuZXZlciBjYWxsZWQgd2l0aCAlcycsIGV4cGVjdGVkQXJncyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9Ob3RIYXZlQmVlbkNhbGxlZCA9IGZ1bmN0aW9uIHRvTm90SGF2ZUJlZW5DYWxsZWQobWVzc2FnZSkge1xuICAgIHZhciBzcHkgPSB0aGlzLmFjdHVhbDtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1NweVV0aWxzLmlzU3B5KHNweSksICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b05vdEhhdmVCZWVuQ2FsbGVkKCkgbXVzdCBiZSBhIHNweScpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShzcHkuY2FsbHMubGVuZ3RoID09PSAwLCBtZXNzYWdlIHx8ICdzcHkgd2FzIG5vdCBzdXBwb3NlZCB0byBiZSBjYWxsZWQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS53aXRoQ29udGV4dCA9IGZ1bmN0aW9uIHdpdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNGdW5jdGlvbih0aGlzLmFjdHVhbCksICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS53aXRoQ29udGV4dCgpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS53aXRoQXJncyA9IGZ1bmN0aW9uIHdpdGhBcmdzKCkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKHRoaXMuYWN0dWFsKSwgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLndpdGhBcmdzKCkgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgdGhpcy5hcmdzID0gdGhpcy5hcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBFeHBlY3RhdGlvbjtcbn0pKCk7XG5cbnZhciBhbGlhc2VzID0ge1xuICB0b0JlQW46ICd0b0JlQScsXG4gIHRvTm90QmVBbjogJ3RvTm90QmVBJyxcbiAgdG9CZVRydXRoeTogJ3RvRXhpc3QnLFxuICB0b0JlRmFsc3k6ICd0b05vdEV4aXN0JyxcbiAgdG9CZUZld2VyVGhhbjogJ3RvQmVMZXNzVGhhbicsXG4gIHRvQmVNb3JlVGhhbjogJ3RvQmVHcmVhdGVyVGhhbicsXG4gIHRvQ29udGFpbjogJ3RvSW5jbHVkZScsXG4gIHRvTm90Q29udGFpbjogJ3RvRXhjbHVkZSdcbn07XG5cbmZvciAodmFyIGFsaWFzIGluIGFsaWFzZXMpIHtcbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlW2FsaWFzXSA9IEV4cGVjdGF0aW9uLnByb3RvdHlwZVthbGlhc2VzW2FsaWFzXV07XG59ZXhwb3J0c1snZGVmYXVsdCddID0gRXhwZWN0YXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZVNweSA9IGNyZWF0ZVNweTtcbmV4cG9ydHMuc3B5T24gPSBzcHlPbjtcbmV4cG9ydHMuaXNTcHkgPSBpc1NweTtcbmV4cG9ydHMucmVzdG9yZVNwaWVzID0gcmVzdG9yZVNwaWVzO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcblxudmFyIF9hc3NlcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzZXJ0KTtcblxudmFyIF9UZXN0VXRpbHMgPSByZXF1aXJlKCcuL1Rlc3RVdGlscycpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIHNwaWVzID0gW107XG5cbmZ1bmN0aW9uIGNyZWF0ZVNweShmbikge1xuICB2YXIgcmVzdG9yZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG5vb3AgOiBhcmd1bWVudHNbMV07XG5cbiAgaWYgKGZuID09IG51bGwpIGZuID0gbm9vcDtcblxuICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNGdW5jdGlvbihmbiksICdjcmVhdGVTcHkgbmVlZHMgYSBmdW5jdGlvbicpO1xuXG4gIHZhciB0YXJnZXRGbiA9IHVuZGVmaW5lZCxcbiAgICAgIHRocm93blZhbHVlID0gdW5kZWZpbmVkLFxuICAgICAgcmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgdmFyIHNweSA9IGZ1bmN0aW9uIHNweSgpIHtcbiAgICBzcHkuY2FsbHMucHVzaCh7XG4gICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgYXJndW1lbnRzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG4gICAgfSk7XG5cbiAgICBpZiAodGFyZ2V0Rm4pIHJldHVybiB0YXJnZXRGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRocm93blZhbHVlKSB0aHJvdyB0aHJvd25WYWx1ZTtcblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcblxuICBzcHkuY2FsbHMgPSBbXTtcblxuICBzcHkuYW5kQ2FsbCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHRhcmdldEZuID0gZm47XG4gICAgcmV0dXJuIHNweTtcbiAgfTtcblxuICBzcHkuYW5kQ2FsbFRocm91Z2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNweS5hbmRDYWxsKGZuKTtcbiAgfTtcblxuICBzcHkuYW5kVGhyb3cgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdGhyb3duVmFsdWUgPSBvYmplY3Q7XG4gICAgcmV0dXJuIHNweTtcbiAgfTtcblxuICBzcHkuYW5kUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuVmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gc3B5O1xuICB9O1xuXG4gIHNweS5nZXRMYXN0Q2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3B5LmNhbGxzW3NweS5jYWxscy5sZW5ndGggLSAxXTtcbiAgfTtcblxuICBzcHkucmVzdG9yZSA9IHNweS5kZXN0cm95ID0gcmVzdG9yZTtcblxuICBzcHkuX19pc1NweSA9IHRydWU7XG5cbiAgc3BpZXMucHVzaChzcHkpO1xuXG4gIHJldHVybiBzcHk7XG59XG5cbmZ1bmN0aW9uIHNweU9uKG9iamVjdCwgbWV0aG9kTmFtZSkge1xuICB2YXIgb3JpZ2luYWwgPSBvYmplY3RbbWV0aG9kTmFtZV07XG5cbiAgaWYgKCFpc1NweShvcmlnaW5hbCkpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuaXNGdW5jdGlvbihvcmlnaW5hbCksICdDYW5ub3Qgc3B5T24gdGhlICVzIHByb3BlcnR5OyBpdCBpcyBub3QgYSBmdW5jdGlvbicsIG1ldGhvZE5hbWUpO1xuXG4gICAgb2JqZWN0W21ldGhvZE5hbWVdID0gY3JlYXRlU3B5KG9yaWdpbmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBvcmlnaW5hbDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3RbbWV0aG9kTmFtZV07XG59XG5cbmZ1bmN0aW9uIGlzU3B5KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fX2lzU3B5ID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlU3BpZXMoKSB7XG4gIGZvciAodmFyIGkgPSBzcGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHNwaWVzW2ldLnJlc3RvcmUoKTtcbiAgfXNwaWVzID0gW107XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5mdW5jdGlvblRocm93cyA9IGZ1bmN0aW9uVGhyb3dzO1xuZXhwb3J0cy5hcnJheUNvbnRhaW5zID0gYXJyYXlDb250YWlucztcbmV4cG9ydHMuc3RyaW5nQ29udGFpbnMgPSBzdHJpbmdDb250YWlucztcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc0EgPSBpc0E7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9kZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbnZhciBfaXNSZWdleHAgPSByZXF1aXJlKCdpcy1yZWdleHAnKTtcblxudmFyIF9pc1JlZ2V4cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1JlZ2V4cCk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmdW5jdGlvbiB0aHJvd3MgdGhlIGdpdmVuIHZhbHVlXG4gKiB3aGVuIGludm9rZWQuIFRoZSB2YWx1ZSBtYXkgYmU6XG4gKlxuICogLSB1bmRlZmluZWQsIHRvIG1lcmVseSBhc3NlcnQgdGhlcmUgd2FzIGEgdGhyb3dcbiAqIC0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgZm9yIGNvbXBhcmluZyB1c2luZyBpbnN0YW5jZW9mXG4gKiAtIGEgcmVndWxhciBleHByZXNzaW9uLCB0byBjb21wYXJlIHdpdGggdGhlIGVycm9yIG1lc3NhZ2VcbiAqIC0gYSBzdHJpbmcsIHRvIGZpbmQgaW4gdGhlIGVycm9yIG1lc3NhZ2VcbiAqL1xuXG5mdW5jdGlvbiBmdW5jdGlvblRocm93cyhmbiwgY29udGV4dCwgYXJncywgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZXJyb3IgaW5zdGFuY2VvZiB2YWx1ZSkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3I7XG5cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoX2lzUmVnZXhwMlsnZGVmYXVsdCddKHZhbHVlKSAmJiB2YWx1ZS50ZXN0KGVycm9yLm1lc3NhZ2UpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZS5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFycmF5IGNvbnRhaW5zIHRoZSB2YWx1ZSwgZmFsc2VcbiAqIG90aGVyd2lzZS4gVGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gbXVzdCByZXR1cm4gZmFsc2UgdG9cbiAqIGluZGljYXRlIGEgbm9uLW1hdGNoLlxuICovXG5cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnMoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIGlmIChjb21wYXJhdG9yID09IG51bGwpIGNvbXBhcmF0b3IgPSBfZGVlcEVxdWFsMlsnZGVmYXVsdCddO1xuXG4gIHJldHVybiBhcnJheS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGNvbXBhcmF0b3IoaXRlbSwgdmFsdWUpICE9PSBmYWxzZTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgdGhlIHZhbHVlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nQ29udGFpbnMoc3RyaW5nLCB2YWx1ZSkge1xuICByZXR1cm4gc3RyaW5nLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBhcnJheS5cbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KG9iamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmplY3QpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2VvZiB2YWx1ZVxuICogb3IgaXRzIHR5cGVvZiBpcyB0aGUgZ2l2ZW4gdmFsdWUuXG4gKi9cblxuZnVuY3Rpb24gaXNBKG9iamVjdCwgdmFsdWUpIHtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSAnYXJyYXknKSByZXR1cm4gQXJyYXkuaXNBcnJheShvYmplY3QpO1xuXG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSB2YWx1ZTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9vYmplY3RJbnNwZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWluc3BlY3QnKTtcblxudmFyIF9vYmplY3RJbnNwZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdEluc3BlY3QpO1xuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlRm9ybWF0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBleHRyYUFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZXh0cmFBcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChjb25kaXRpb24pIHJldHVybjtcblxuICB2YXIgaW5kZXggPSAwO1xuXG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX29iamVjdEluc3BlY3QyWydkZWZhdWx0J10oZXh0cmFBcmdzW2luZGV4KytdKTtcbiAgfSkpO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBhc3NlcnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9FeHBlY3RhdGlvbiA9IHJlcXVpcmUoJy4vRXhwZWN0YXRpb24nKTtcblxudmFyIF9FeHBlY3RhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FeHBlY3RhdGlvbik7XG5cbnZhciBFeHRlbnNpb25zID0gW107XG5cbmZ1bmN0aW9uIGV4dGVuZChleHRlbnNpb24pIHtcbiAgaWYgKEV4dGVuc2lvbnMuaW5kZXhPZihleHRlbnNpb24pID09PSAtMSkge1xuICAgIEV4dGVuc2lvbnMucHVzaChleHRlbnNpb24pO1xuXG4gICAgZm9yICh2YXIgcCBpbiBleHRlbnNpb24pIHtcbiAgICAgIGlmIChleHRlbnNpb24uaGFzT3duUHJvcGVydHkocCkpIF9FeHBlY3RhdGlvbjJbJ2RlZmF1bHQnXS5wcm90b3R5cGVbcF0gPSBleHRlbnNpb25bcF07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGV4dGVuZDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0V4cGVjdGF0aW9uID0gcmVxdWlyZSgnLi9FeHBlY3RhdGlvbicpO1xuXG52YXIgX0V4cGVjdGF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V4cGVjdGF0aW9uKTtcblxudmFyIF9TcHlVdGlscyA9IHJlcXVpcmUoJy4vU3B5VXRpbHMnKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuXG52YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnQpO1xuXG52YXIgX2V4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbmZ1bmN0aW9uIGV4cGVjdChhY3R1YWwpIHtcbiAgcmV0dXJuIG5ldyBfRXhwZWN0YXRpb24yWydkZWZhdWx0J10oYWN0dWFsKTtcbn1cblxuZXhwZWN0LmNyZWF0ZVNweSA9IF9TcHlVdGlscy5jcmVhdGVTcHk7XG5leHBlY3Quc3B5T24gPSBfU3B5VXRpbHMuc3B5T247XG5leHBlY3QuaXNTcHkgPSBfU3B5VXRpbHMuaXNTcHk7XG5leHBlY3QucmVzdG9yZVNwaWVzID0gX1NweVV0aWxzLnJlc3RvcmVTcGllcztcbmV4cGVjdC5hc3NlcnQgPSBfYXNzZXJ0MlsnZGVmYXVsdCddO1xuZXhwZWN0LmV4dGVuZCA9IF9leHRlbmQyWydkZWZhdWx0J107XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGV4cGVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMuanMnKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vbGliL2lzX2FyZ3VtZW50cy5qcycpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG4iLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlKSB7XG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluc3BlY3RfIChvYmosIG9wdHMsIGRlcHRoLCBzZWVuKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgXG4gICAgdmFyIG1heERlcHRoID0gb3B0cy5kZXB0aCA9PT0gdW5kZWZpbmVkID8gNSA6IG9wdHMuZGVwdGg7XG4gICAgaWYgKGRlcHRoID09PSB1bmRlZmluZWQpIGRlcHRoID0gMDtcbiAgICBpZiAoZGVwdGggPj0gbWF4RGVwdGggJiYgbWF4RGVwdGggPiAwXG4gICAgJiYgb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiAnW09iamVjdF0nO1xuICAgIH1cbiAgICBcbiAgICBpZiAoc2VlbiA9PT0gdW5kZWZpbmVkKSBzZWVuID0gW107XG4gICAgZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBvYmopID49IDApIHtcbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gaW5zcGVjdCAodmFsdWUsIGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuLnNsaWNlKCk7XG4gICAgICAgICAgICBzZWVuLnB1c2goZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBvcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgIH1cbiAgICBcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGluc3BlY3RTdHJpbmcob2JqKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xuICAgICAgICByZXR1cm4gJ1tGdW5jdGlvbicgKyAobmFtZSA/ICc6ICcgKyBuYW1lIDogJycpICsgJ10nO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyA/ICdPYmplY3QoJyArIHN5bVN0cmluZyArICcpJyA6IHN5bVN0cmluZztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFbGVtZW50KG9iaikpIHtcbiAgICAgICAgdmFyIHMgPSAnPCcgKyBTdHJpbmcob2JqLm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz1cIicgKyBxdW90ZShhdHRyc1tpXS52YWx1ZSkgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gJz4nO1xuICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXMgJiYgb2JqLmNoaWxkTm9kZXMubGVuZ3RoKSBzICs9ICcuLi4nO1xuICAgICAgICBzICs9ICc8LycgKyBTdHJpbmcob2JqLm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpICsgJz4nO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAwKSByZXR1cm4gJ1tdJztcbiAgICAgICAgdmFyIHhzID0gQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB4c1tpXSA9IGhhcyhvYmosIGkpID8gaW5zcGVjdChvYmpbaV0sIG9iaikgOiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1sgJyArIHhzLmpvaW4oJywgJykgKyAnIF0nO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Vycm9yKG9iaikpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICghaGFzKG9iaiwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICgvW15cXHckXS8udGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChpbnNwZWN0KGtleSkgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChrZXkgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHJldHVybiAnWycgKyBvYmogKyAnXSc7XG4gICAgICAgIHJldHVybiAneyBbJyArIG9iaiArICddICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9JztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBvYmouaW5zcGVjdCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaXNEYXRlKG9iaikgJiYgIWlzUmVnRXhwKG9iaikpIHtcbiAgICAgICAgdmFyIHhzID0gW10sIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKC9bXlxcdyRdLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICB4cy5wdXNoKGluc3BlY3Qoa2V5KSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeHMucHVzaChrZXkgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICd7fSc7XG4gICAgICAgIHJldHVybiAneyAnICsgeHMuam9pbignLCAnKSArICcgfSc7XG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIFN0cmluZyhvYmopO1xufTtcblxuZnVuY3Rpb24gcXVvdGUgKHMpIHtcbiAgICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBBcnJheV0nIH1cbmZ1bmN0aW9uIGlzRGF0ZSAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBEYXRlXScgfVxuZnVuY3Rpb24gaXNSZWdFeHAgKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfVxuZnVuY3Rpb24gaXNFcnJvciAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBFcnJvcl0nIH1cbmZ1bmN0aW9uIGlzU3ltYm9sIChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFN5bWJvbF0nIH1cblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5IGluIHRoaXM7IH07XG5mdW5jdGlvbiBoYXMgKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn1cblxuZnVuY3Rpb24gdG9TdHIgKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gbmFtZU9mIChmKSB7XG4gICAgaWYgKGYubmFtZSkgcmV0dXJuIGYubmFtZTtcbiAgICB2YXIgbSA9IGYudG9TdHJpbmcoKS5tYXRjaCgvXmZ1bmN0aW9uXFxzKihbXFx3JF0rKS8pO1xuICAgIGlmIChtKSByZXR1cm4gbVsxXTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQgKHgpIHtcbiAgICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHgubm9kZU5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICYmIHR5cGVvZiB4LmdldEF0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgIDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFN0cmluZyAoc3RyKSB7XG4gICAgdmFyIHMgPSBzdHIucmVwbGFjZSgvKFsnXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9bXFx4MDAtXFx4MWZdL2csIGxvd2J5dGUpO1xuICAgIHJldHVybiBcIidcIiArIHMgKyBcIidcIjtcbiAgICBcbiAgICBmdW5jdGlvbiBsb3dieXRlIChjKSB7XG4gICAgICAgIHZhciBuID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICB2YXIgeCA9IHsgODogJ2InLCA5OiAndCcsIDEwOiAnbicsIDEyOiAnZicsIDEzOiAncicgfVtuXTtcbiAgICAgICAgaWYgKHgpIHJldHVybiAnXFxcXCcgKyB4O1xuICAgICAgICByZXR1cm4gJ1xcXFx4JyArIChuIDwgMHgxMCA/ICcwJyA6ICcnKSArIG4udG9TdHJpbmcoMTYpO1xuICAgIH1cbn1cbiIsIi8vIFVzaW5nIGFuIEVTNiB0cmFuc3BpbGVyLCBsaWtlIGJhYmVsIFxuaW1wb3J0IGV4cGVjdCBmcm9tICdleHBlY3QnO1xuaW1wb3J0IGRlZXBGcmVlemUgZnJvbSAnZGVlcC1mcmVlemUtc3RyaWN0JztcblxuY29uc3QgdG9kbyA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG5cdHN3aXRjaChhY3Rpb24udHlwZSkge1xuXHRcdGNhc2UgJ0FERF9UT0RPJzpcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkOiBhY3Rpb24uaWQsXG5cdFx0XHRcdHRleHQ6IGFjdGlvbi50ZXh0LFxuXHRcdFx0XHRjb21wbGV0ZWQ6IGZhbHNlXG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnVE9HR0xFX1RPRE8nOlx0XHRcdFxuXHRcdFx0aWYoc3RhdGUuaWQgIT09IGFjdGlvbi5pZCkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgeyAnY29tcGxldGVkJzogIXN0YXRlLmNvbXBsZXRlZCB9KTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn07XG5cblxuY29uc3QgdG9kb3MgPSAoc3RhdGUgPSBbXSwgYWN0aW9uKSA9PiB7XG5cdHN3aXRjaChhY3Rpb24udHlwZSkge1xuXHRcdGNhc2UgJ0FERF9UT0RPJzpcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdC4uLnN0YXRlLFxuXHRcdFx0XHR0b2RvKHVuZGVmaW5lZCwgYWN0aW9uKVxuXHRcdFx0XTtcblxuXHRcdGNhc2UgJ1RPR0dMRV9UT0RPJzpcblx0XHRcdHJldHVybiBzdGF0ZS5tYXAodCA9PiB0b2RvKHQsIGFjdGlvbikpO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBzdGF0ZTtcblx0fVxufTtcblxuY29uc3QgdmlzaWJpbGl0eUZpbHRlciA9IChcblx0c3RhdGUgPSAnU0hPV19BTEwnLFxuXHRhY3Rpb25cbikgPT4ge1xuXHRzd2l0Y2goYWN0aW9uLnR5cGUpIHtcblx0XHRjYXNlICdTRVRfVklTSUJJTElUWV9GSUxURVInOlxuXHRcdFx0cmV0dXJuIGFjdGlvbi5maWx0ZXI7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG59O1xuXG5cbmNvbnN0IHsgY29tYmluZVJlZHVjZXJzIH0gPSBSZWR1eDtcbmNvbnN0IHRvZG9BcHAgPSBjb21iaW5lUmVkdWNlcnMoe1xuXHQvLyBTaG9ydDpcblx0dG9kb3MsXG5cdHZpc2liaWxpdHlGaWx0ZXJcblxuXHQvLyBMb25nOlxuXHQvKiB0b2RvczogdG9kb3MsXG5cdC8qIHZpc2liaWxpdHlGaWx0ZXI6IHZpc2liaWxpdHlGaWx0ZXJcblx0Ki9cbn0pO1xuXG5jb25zdCB7IGNyZWF0ZVN0b3JlIH0gPSBSZWR1eDtcbmNvbnN0IHN0b3JlID0gY3JlYXRlU3RvcmUodG9kb0FwcCk7XG5cbmNvbnN0IHsgQ29tcG9uZW50IH0gPSBSZWFjdDtcblxuY29uc3QgVG9kbyA9ICh7XG5cdG9uQ2xpY2ssXG5cdGNvbXBsZXRlZCxcblx0dGV4dFxufSkgPT4gKFxuXHQ8bGlcblx0XHRvbkNsaWNrPXtcblx0XHRcdG9uQ2xpY2tcblx0XHR9XG5cdFx0c3R5bGU9e3tcblx0XHRcdHRleHREZWNvcmF0aW9uOlxuXHRcdFx0XHRjb21wbGV0ZWQgP1xuXHRcdFx0XHRcdCdsaW5lLXRocm91Z2gnOlxuXHRcdFx0XHRcdCdub25lJ1xuXHRcdH19XG5cdD5cblx0XHR7dGV4dH1cblx0PC9saT5cbik7XG5cbmNvbnN0IFRvZG9MaXN0ID0gKHtcblx0dG9kb3MsXG5cdG9uVG9kb0NsaWNrXG59KSA9PiAoXG5cdDx1bD5cblx0XHR7dG9kb3MubWFwKHRvZG8gPT4gXG5cdFx0XHQ8VG9kb1xuXHRcdFx0XHRrZXk9e3RvZG8uaWR9XG5cdFx0XHRcdHsuLi50b2RvfVxuXHRcdFx0XHRvbkNsaWNrPXsoKSA9PiBvblRvZG9DbGljayh0b2RvLmlkKX1cblx0XHRcdC8+XG5cdFx0KX1cblx0PC91bD5cbik7XG5cbmNvbnN0IExpbmsgPSAoe1xuXHRhY3RpdmUsXG5cdGNoaWxkcmVuLFxuXHRvbkNsaWNrXG59KSA9PiB7XG5cdGlmKGFjdGl2ZSkge1xuXHRcdHJldHVybiA8c3Bhbj57Y2hpbGRyZW59PC9zcGFuPjtcblx0fVxuXHRyZXR1cm4gKFxuXHRcdDxhIGhyZWY9JyMnXG5cdFx0XHRvbkNsaWNrPXtlID0+IHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRvbkNsaWNrKCk7XG5cdFx0XHR9fVxuXHRcdD5cblx0XHRcdHtjaGlsZHJlbn1cblx0XHQ8L2E+XG5cdCk7XG59O1xuXG5jbGFzcyBGaWx0ZXJMaW5rIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29tcG9uZW50ZGlkTW91bnQoKSB7XG5cdFx0dGhpcy51bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSgoKSA9PlxuXHRcdFx0dGhpcy5mb3JjZVVwZGF0ZSgpXG5cdFx0KTtcblx0fVxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdHRoaXMudW5zdWJzY3JpYmUoKTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG5cdFx0Y29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxMaW5rIFxuXHRcdFx0XHRhY3RpdmU9e1xuXHRcdFx0XHRcdHByb3BzLmZpbHRlciA9PT0gc3RhdGUudmlzaWJpbGl0eUZpbHRlclxuXHRcdFx0XHR9XG5cdFx0XHRcdG9uQ2xpY2s9eygpID0+XG5cdFx0XHRcdFx0c3RvcmUuZGlzcGF0Y2goe1xuXHRcdFx0XHRcdFx0dHlwZTogJ1NFVF9WSVNJQklMSVRZX0ZJTFRFUicsXG5cdFx0XHRcdFx0XHRmaWx0ZXI6IHByb3BzLmZpbHRlclxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdD5cblx0XHRcdHtwcm9wcy5jaGlsZHJlbn1cblx0XHRcdDwvTGluaz5cblx0XHQpXG5cdH1cbn07XG5cbmNvbnN0IEZvb3RlciA9ICgpID0+IChcblx0PHA+XG5cdFx0U2hvdzpcblx0XHR7JyAnfVxuXHRcdDxGaWx0ZXJMaW5rXG5cdFx0XHRmaWx0ZXI9J1NIT1dfQUxMJ1xuXHRcdD5cblx0XHRcdEFsbFxuXHRcdDwvRmlsdGVyTGluaz5cblx0XHR7JywgJ31cblx0XHQ8RmlsdGVyTGlua1xuXHRcdFx0ZmlsdGVyPSdTSE9XX0FDVElWRSdcblx0XHQ+XG5cdFx0XHRBY3RpdmVcblx0XHQ8L0ZpbHRlckxpbms+XG5cdFx0eycsICd9XG5cdFx0PEZpbHRlckxpbmtcblx0XHRcdGZpbHRlcj0nU0hPV19DT01QTEVURUQnXG5cdFx0PlxuXHRcdFx0Q29tcGxldGVkXG5cdFx0PC9GaWx0ZXJMaW5rPlxuXHQ8L3A+XG4pO1xuXG5jb25zdCBBZGRUb2RvID0gKCkgPT4ge1xuXHRsZXQgaW5wdXQ7XG5cblx0cmV0dXJuIChcblx0XHQ8ZGl2PlxuXHRcdFx0PGlucHV0IHJlZj17bm9kZSA9PiB7XG5cdFx0XHRcdGlucHV0ID0gbm9kZTtcblx0XHRcdH19IC8+XG5cdFx0XHQ8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHtcblx0XHRcdFx0c3RvcmUuZGlzcGF0Y2goe1xuXHRcdFx0XHRcdHR5cGU6ICdBRERfVE9ETycsXG5cdFx0XHRcdFx0aWQ6IG5leHRUb2RvSWQrKyxcblx0XHRcdFx0XHR0ZXh0OiBpbnB1dC52YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbnB1dC52YWx1ZSA9ICcnO1xuXHRcdFx0fX0+XG5cdFx0XHRBZGQgVG9kb1xuXHRcdFx0PC9idXR0b24+XG5cdFx0PC9kaXY+XG5cdCk7XG59O1xuXG5jb25zdCBnZXRWaXNpYmxlVG9kb3MgPSAoXG5cdHRvZG9zLFxuXHRmaWx0ZXJcbikgPT4ge1xuXHRzd2l0Y2goZmlsdGVyKSB7XG5cdFx0Y2FzZSAnU0hPV19BTEwnOlxuXHRcdFx0cmV0dXJuIHRvZG9zO1xuXG5cdFx0Y2FzZSAnU0hPV19DT01QTEVURUQnOlxuXHRcdFx0cmV0dXJuIHRvZG9zLmZpbHRlcihcblx0XHRcdFx0dCA9PiB0LmNvbXBsZXRlZFxuXHRcdFx0KTtcblxuXHRcdGNhc2UgJ1NIT1dfQUNUSVZFJzpcblx0XHRcdHJldHVybiB0b2Rvcy5maWx0ZXIoXG5cdFx0XHRcdHQgPT4gIXQuY29tcGxldGVkXG5cdFx0XHQpO1xuXHR9XG59XG5cbmNsYXNzIFZpc2libGVUb2RvTGlzdCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbXBvbmVudGRpZE1vdW50KCkge1xuXHRcdHRoaXMudW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUoKCkgPT5cblx0XHRcdHRoaXMuZm9yY2VVcGRhdGUoKVxuXHRcdCk7XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR0aGlzLnVuc3Vic2NyaWJlKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuXHRcdGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8VG9kb0xpc3Rcblx0XHRcdFx0dG9kb3M9e1xuXHRcdFx0XHRcdGdldFZpc2libGVUb2Rvcyhcblx0XHRcdFx0XHRcdHN0YXRlLnRvZG9zLFxuXHRcdFx0XHRcdFx0c3RhdGUudmlzaWJpbGl0eUZpbHRlclxuXHRcdFx0XHRcdClcblx0XHRcdFx0fVxuXHRcdFx0XHRvblRvZG9DbGljaz17aWQgPT5cblx0XHRcdFx0XHRzdG9yZS5kaXNwYXRjaCh7XG5cdFx0XHRcdFx0XHR0eXBlOiAnVE9HR0xFX1RPRE8nLFxuXHRcdFx0XHRcdFx0aWRcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9IC8+XG5cdFx0KTtcblx0fVxufTtcblxubGV0IG5leHRUb2RvSWQgPSAwO1xuXG5jb25zdCBUb2RvQXBwID0gKCkgPT4gKFx0XG5cdDxkaXY+XG5cdFx0PEFkZFRvZG8gLz5cblx0XHQ8VmlzaWJsZVRvZG9MaXN0IC8+XG5cdFx0PEZvb3RlciAvPlx0XHRcblx0PC9kaXY+XG4pO1xuXG5jb25zdCByZW5kZXIgPSAoKSA9PiB7XG5cdFJlYWN0RE9NLnJlbmRlcihcblx0XHQ8VG9kb0FwcCAvPixcblx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpXG5cdCk7XG59O1xuXG5zdG9yZS5zdWJzY3JpYmUocmVuZGVyKTtcbnJlbmRlcigpO1xuIl19
