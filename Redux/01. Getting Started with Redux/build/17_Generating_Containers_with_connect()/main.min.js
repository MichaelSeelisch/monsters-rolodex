(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = function deepFreeze (o) {
  Object.freeze(o);

  var oIsFunction = typeof o === "function";
  var hasOwnProp = Object.prototype.hasOwnProperty;

  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (hasOwnProp.call(o, prop)
    && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true )
    && o[prop] !== null
    && (typeof o[prop] === "object" || typeof o[prop] === "function")
    && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  
  return o;
};

},{}],2:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _isRegexp = require('is-regexp');

var _isRegexp2 = _interopRequireDefault(_isRegexp);

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _SpyUtils = require('./SpyUtils');

var _TestUtils = require('./TestUtils');

/**
 * An Expectation is a wrapper around an assertion that allows it to be written
 * in a more natural style, without the need to remember the order of arguments.
 * This helps prevent you from making mistakes when writing tests.
 */

var Expectation = (function () {
  function Expectation(actual) {
    _classCallCheck(this, Expectation);

    this.actual = actual;

    if (_TestUtils.isFunction(actual)) {
      this.context = null;
      this.args = [];
    }
  }

  Expectation.prototype.toExist = function toExist(message) {
    _assert2['default'](this.actual, message || 'Expected %s to exist', this.actual);

    return this;
  };

  Expectation.prototype.toNotExist = function toNotExist(message) {
    _assert2['default'](!this.actual, message || 'Expected %s to not exist', this.actual);

    return this;
  };

  Expectation.prototype.toBe = function toBe(value, message) {
    _assert2['default'](this.actual === value, message || 'Expected %s to be %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toNotBe = function toNotBe(value, message) {
    _assert2['default'](this.actual !== value, message || 'Expected %s to not be %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toEqual = function toEqual(value, message) {
    try {
      _assert2['default'](_deepEqual2['default'](this.actual, value), message || 'Expected %s to equal %s', this.actual, value);
    } catch (e) {
      // These attributes are consumed by Mocha to produce a diff output.
      e.showDiff = true;
      e.actual = this.actual;
      e.expected = value;
      throw e;
    }

    return this;
  };

  Expectation.prototype.toNotEqual = function toNotEqual(value, message) {
    _assert2['default'](!_deepEqual2['default'](this.actual, value), message || 'Expected %s to not equal %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toThrow = function toThrow(value, message) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).toThrow() must be a function, %s was given', this.actual);

    _assert2['default'](_TestUtils.functionThrows(this.actual, this.context, this.args, value), message || 'Expected %s to throw %s', this.actual, value || 'an error');

    return this;
  };

  Expectation.prototype.toNotThrow = function toNotThrow(value, message) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).toNotThrow() must be a function, %s was given', this.actual);

    _assert2['default'](!_TestUtils.functionThrows(this.actual, this.context, this.args, value), message || 'Expected %s to not throw %s', this.actual, value || 'an error');

    return this;
  };

  Expectation.prototype.toBeA = function toBeA(value, message) {
    _assert2['default'](_TestUtils.isFunction(value) || typeof value === 'string', 'The "value" argument in toBeA(value) must be a function or a string');

    _assert2['default'](_TestUtils.isA(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toNotBeA = function toNotBeA(value, message) {
    _assert2['default'](_TestUtils.isFunction(value) || typeof value === 'string', 'The "value" argument in toNotBeA(value) must be a function or a string');

    _assert2['default'](!_TestUtils.isA(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toMatch = function toMatch(pattern, message) {
    _assert2['default'](typeof this.actual === 'string', 'The "actual" argument in expect(actual).toMatch() must be a string');

    _assert2['default'](_isRegexp2['default'](pattern), 'The "value" argument in toMatch(value) must be a RegExp');

    _assert2['default'](pattern.test(this.actual), message || 'Expected %s to match %s', this.actual, pattern);

    return this;
  };

  Expectation.prototype.toNotMatch = function toNotMatch(pattern, message) {
    _assert2['default'](typeof this.actual === 'string', 'The "actual" argument in expect(actual).toNotMatch() must be a string');

    _assert2['default'](_isRegexp2['default'](pattern), 'The "value" argument in toNotMatch(value) must be a RegExp');

    _assert2['default'](!pattern.test(this.actual), message || 'Expected %s to not match %s', this.actual, pattern);

    return this;
  };

  Expectation.prototype.toBeLessThan = function toBeLessThan(value, message) {
    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThan() must be a number');

    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeLessThan(value) must be a number');

    _assert2['default'](this.actual < value, message || 'Expected %s to be less than %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toBeGreaterThan = function toBeGreaterThan(value, message) {
    _assert2['default'](typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThan() must be a number');

    _assert2['default'](typeof value === 'number', 'The "value" argument in toBeGreaterThan(value) must be a number');

    _assert2['default'](this.actual > value, message || 'Expected %s to be greater than %s', this.actual, value);

    return this;
  };

  Expectation.prototype.toInclude = function toInclude(value, comparator, message) {
    _assert2['default'](_TestUtils.isArray(this.actual) || typeof this.actual === 'string', 'The "actual" argument in expect(actual).toInclude() must be an array or a string');

    if (typeof comparator === 'string') {
      message = comparator;
      comparator = null;
    }

    message = message || 'Expected %s to include %s';

    if (_TestUtils.isArray(this.actual)) {
      _assert2['default'](_TestUtils.arrayContains(this.actual, value, comparator), message, this.actual, value);
    } else {
      _assert2['default'](_TestUtils.stringContains(this.actual, value), message, this.actual, value);
    }

    return this;
  };

  Expectation.prototype.toExclude = function toExclude(value, comparator, message) {
    _assert2['default'](_TestUtils.isArray(this.actual) || typeof this.actual === 'string', 'The "actual" argument in expect(actual).toExclude() must be an array or a string');

    if (typeof comparator === 'string') {
      message = comparator;
      comparator = null;
    }

    message = message || 'Expected %s to exclude %s';

    if (_TestUtils.isArray(this.actual)) {
      _assert2['default'](!_TestUtils.arrayContains(this.actual, value, comparator), message, this.actual, value);
    } else {
      _assert2['default'](!_TestUtils.stringContains(this.actual, value), message, this.actual, value);
    }

    return this;
  };

  Expectation.prototype.toHaveBeenCalled = function toHaveBeenCalled(message) {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toHaveBeenCalled() must be a spy');

    _assert2['default'](spy.calls.length > 0, message || 'spy was not called');

    return this;
  };

  Expectation.prototype.toHaveBeenCalledWith = function toHaveBeenCalledWith() {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toHaveBeenCalledWith() must be a spy');

    var expectedArgs = Array.prototype.slice.call(arguments, 0);

    _assert2['default'](spy.calls.some(function (call) {
      return _deepEqual2['default'](call.arguments, expectedArgs);
    }), 'spy was never called with %s', expectedArgs);

    return this;
  };

  Expectation.prototype.toNotHaveBeenCalled = function toNotHaveBeenCalled(message) {
    var spy = this.actual;

    _assert2['default'](_SpyUtils.isSpy(spy), 'The "actual" argument in expect(actual).toNotHaveBeenCalled() must be a spy');

    _assert2['default'](spy.calls.length === 0, message || 'spy was not supposed to be called');

    return this;
  };

  Expectation.prototype.withContext = function withContext(context) {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).withContext() must be a function');

    this.context = context;

    return this;
  };

  Expectation.prototype.withArgs = function withArgs() {
    _assert2['default'](_TestUtils.isFunction(this.actual), 'The "actual" argument in expect(actual).withArgs() must be a function');

    if (arguments.length) this.args = this.args.concat(Array.prototype.slice.call(arguments, 0));

    return this;
  };

  return Expectation;
})();

var aliases = {
  toBeAn: 'toBeA',
  toNotBeAn: 'toNotBeA',
  toBeTruthy: 'toExist',
  toBeFalsy: 'toNotExist',
  toBeFewerThan: 'toBeLessThan',
  toBeMoreThan: 'toBeGreaterThan',
  toContain: 'toInclude',
  toNotContain: 'toExclude'
};

for (var alias in aliases) {
  Expectation.prototype[alias] = Expectation.prototype[aliases[alias]];
}exports['default'] = Expectation;
module.exports = exports['default'];
},{"./SpyUtils":3,"./TestUtils":4,"./assert":5,"deep-equal":8,"is-regexp":11}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.createSpy = createSpy;
exports.spyOn = spyOn;
exports.isSpy = isSpy;
exports.restoreSpies = restoreSpies;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _TestUtils = require('./TestUtils');

function noop() {}

var spies = [];

function createSpy(fn) {
  var restore = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];

  if (fn == null) fn = noop;

  _assert2['default'](_TestUtils.isFunction(fn), 'createSpy needs a function');

  var targetFn = undefined,
      thrownValue = undefined,
      returnValue = undefined;

  var spy = function spy() {
    spy.calls.push({
      context: this,
      arguments: Array.prototype.slice.call(arguments, 0)
    });

    if (targetFn) return targetFn.apply(this, arguments);

    if (thrownValue) throw thrownValue;

    return returnValue;
  };

  spy.calls = [];

  spy.andCall = function (fn) {
    targetFn = fn;
    return spy;
  };

  spy.andCallThrough = function () {
    return spy.andCall(fn);
  };

  spy.andThrow = function (object) {
    thrownValue = object;
    return spy;
  };

  spy.andReturn = function (value) {
    returnValue = value;
    return spy;
  };

  spy.getLastCall = function () {
    return spy.calls[spy.calls.length - 1];
  };

  spy.restore = spy.destroy = restore;

  spy.__isSpy = true;

  spies.push(spy);

  return spy;
}

function spyOn(object, methodName) {
  var original = object[methodName];

  if (!isSpy(original)) {
    _assert2['default'](_TestUtils.isFunction(original), 'Cannot spyOn the %s property; it is not a function', methodName);

    object[methodName] = createSpy(original, function () {
      object[methodName] = original;
    });
  }

  return object[methodName];
}

function isSpy(object) {
  return object && object.__isSpy === true;
}

function restoreSpies() {
  for (var i = spies.length - 1; i >= 0; i--) {
    spies[i].restore();
  }spies = [];
}
},{"./TestUtils":4,"./assert":5}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.functionThrows = functionThrows;
exports.arrayContains = arrayContains;
exports.stringContains = stringContains;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isA = isA;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _isRegexp = require('is-regexp');

var _isRegexp2 = _interopRequireDefault(_isRegexp);

/**
 * Returns true if the given function throws the given value
 * when invoked. The value may be:
 *
 * - undefined, to merely assert there was a throw
 * - a constructor function, for comparing using instanceof
 * - a regular expression, to compare with the error message
 * - a string, to find in the error message
 */

function functionThrows(fn, context, args, value) {
  try {
    fn.apply(context, args);
  } catch (error) {
    if (value == null) return true;

    if (isFunction(value) && error instanceof value) return true;

    var message = error.message || error;

    if (typeof message === 'string') {
      if (_isRegexp2['default'](value) && value.test(error.message)) return true;

      if (typeof value === 'string' && message.indexOf(value) !== -1) return true;
    }
  }

  return false;
}

/**
 * Returns true if the given array contains the value, false
 * otherwise. The comparator function must return false to
 * indicate a non-match.
 */

function arrayContains(array, value, comparator) {
  if (comparator == null) comparator = _deepEqual2['default'];

  return array.some(function (item) {
    return comparator(item, value) !== false;
  });
}

/**
 * Returns true if the given string contains the value, false otherwise.
 */

function stringContains(string, value) {
  return string.indexOf(value) !== -1;
}

/**
 * Returns true if the given object is an array.
 */

function isArray(object) {
  return Array.isArray(object);
}

/**
 * Returns true if the given object is a function.
 */

function isFunction(object) {
  return typeof object === 'function';
}

/**
 * Returns true if the given object is an instanceof value
 * or its typeof is the given value.
 */

function isA(object, value) {
  if (isFunction(value)) return object instanceof value;

  if (value === 'array') return Array.isArray(object);

  return typeof object === value;
}
},{"deep-equal":8,"is-regexp":11}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _objectInspect = require('object-inspect');

var _objectInspect2 = _interopRequireDefault(_objectInspect);

function assert(condition, messageFormat) {
  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    extraArgs[_key - 2] = arguments[_key];
  }

  if (condition) return;

  var index = 0;

  throw new Error(messageFormat.replace(/%s/g, function () {
    return _objectInspect2['default'](extraArgs[index++]);
  }));
}

exports['default'] = assert;
module.exports = exports['default'];
},{"object-inspect":12}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Expectation = require('./Expectation');

var _Expectation2 = _interopRequireDefault(_Expectation);

var Extensions = [];

function extend(extension) {
  if (Extensions.indexOf(extension) === -1) {
    Extensions.push(extension);

    for (var p in extension) {
      if (extension.hasOwnProperty(p)) _Expectation2['default'].prototype[p] = extension[p];
    }
  }
}

exports['default'] = extend;
module.exports = exports['default'];
},{"./Expectation":2}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Expectation = require('./Expectation');

var _Expectation2 = _interopRequireDefault(_Expectation);

var _SpyUtils = require('./SpyUtils');

var _assert = require('./assert');

var _assert2 = _interopRequireDefault(_assert);

var _extend = require('./extend');

var _extend2 = _interopRequireDefault(_extend);

function expect(actual) {
  return new _Expectation2['default'](actual);
}

expect.createSpy = _SpyUtils.createSpy;
expect.spyOn = _SpyUtils.spyOn;
expect.isSpy = _SpyUtils.isSpy;
expect.restoreSpies = _SpyUtils.restoreSpies;
expect.assert = _assert2['default'];
expect.extend = _extend2['default'];

exports['default'] = expect;
module.exports = exports['default'];
},{"./Expectation":2,"./SpyUtils":3,"./assert":5,"./extend":6}],8:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":9,"./lib/keys.js":10}],9:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],10:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],11:[function(require,module,exports){
'use strict';
module.exports = function (re) {
	return Object.prototype.toString.call(re) === '[object RegExp]';
};

},{}],12:[function(require,module,exports){
module.exports = function inspect_ (obj, opts, depth, seen) {
    if (!opts) opts = {};
    
    var maxDepth = opts.depth === undefined ? 5 : opts.depth;
    if (depth === undefined) depth = 0;
    if (depth >= maxDepth && maxDepth > 0
    && obj && typeof obj === 'object') {
        return '[Object]';
    }
    
    if (seen === undefined) seen = [];
    else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }
    
    function inspect (value, from) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        return inspect_(value, opts, depth + 1, seen);
    }
    
    if (typeof obj === 'string') {
        return inspectString(obj);
    }
    else if (typeof obj === 'function') {
        var name = nameOf(obj);
        return '[Function' + (name ? ': ' + name : '') + ']';
    }
    else if (obj === null) {
        return 'null';
    }
    else if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;
    }
    else if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '="' + quote(attrs[i].value) + '"';
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) s += '...';
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    else if (isArray(obj)) {
        if (obj.length === 0) return '[]';
        var xs = Array(obj.length);
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    else if (isError(obj)) {
        var parts = [];
        for (var key in obj) {
            if (!has(obj, key)) continue;
            
            if (/[^\w$]/.test(key)) {
                parts.push(inspect(key) + ': ' + inspect(obj[key]));
            }
            else {
                parts.push(key + ': ' + inspect(obj[key]));
            }
        }
        if (parts.length === 0) return '[' + obj + ']';
        return '{ [' + obj + '] ' + parts.join(', ') + ' }';
    }
    else if (typeof obj === 'object' && typeof obj.inspect === 'function') {
        return obj.inspect();
    }
    else if (typeof obj === 'object' && !isDate(obj) && !isRegExp(obj)) {
        var xs = [], keys = [];
        for (var key in obj) {
            if (has(obj, key)) keys.push(key);
        }
        keys.sort();
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (/[^\w$]/.test(key)) {
                xs.push(inspect(key) + ': ' + inspect(obj[key], obj));
            }
            else xs.push(key + ': ' + inspect(obj[key], obj));
        }
        if (xs.length === 0) return '{}';
        return '{ ' + xs.join(', ') + ' }';
    }
    else return String(obj);
};

function quote (s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray (obj) { return toStr(obj) === '[object Array]' }
function isDate (obj) { return toStr(obj) === '[object Date]' }
function isRegExp (obj) { return toStr(obj) === '[object RegExp]' }
function isError (obj) { return toStr(obj) === '[object Error]' }
function isSymbol (obj) { return toStr(obj) === '[object Symbol]' }

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has (obj, key) {
    return hasOwn.call(obj, key);
}

function toStr (obj) {
    return Object.prototype.toString.call(obj);
}

function nameOf (f) {
    if (f.name) return f.name;
    var m = f.toString().match(/^function\s*([\w$]+)/);
    if (m) return m[1];
}

function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
}

function isElement (x) {
    if (!x || typeof x !== 'object') return false;
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string'
        && typeof x.getAttribute === 'function'
    ;
}

function inspectString (str) {
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return "'" + s + "'";
    
    function lowbyte (c) {
        var n = c.charCodeAt(0);
        var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
        if (x) return '\\' + x;
        return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
    }
}

},{}],13:[function(require,module,exports){
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _expect = require('expect');

var _expect2 = _interopRequireDefault(_expect);

var _deepFreezeStrict = require('deep-freeze-strict');

var _deepFreezeStrict2 = _interopRequireDefault(_deepFreezeStrict);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } // Using an ES6 transpiler, like babel

var todo = function todo(state, action) {
	switch (action.type) {
		case 'ADD_TODO':
			return {
				id: action.id,
				text: action.text,
				completed: false
			};

		case 'TOGGLE_TODO':
			if (state.id !== action.id) {
				return state;
			}

			return Object.assign({}, state, { 'completed': !state.completed });

		default:
			return state;
	}
};

var todos = function todos() {
	var state = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	var action = arguments[1];

	switch (action.type) {
		case 'ADD_TODO':
			return [].concat(_toConsumableArray(state), [todo(undefined, action)]);

		case 'TOGGLE_TODO':
			return state.map(function (t) {
				return todo(t, action);
			});

		default:
			return state;
	}
};

var visibilityFilter = function visibilityFilter() {
	var state = arguments.length <= 0 || arguments[0] === undefined ? 'SHOW_ALL' : arguments[0];
	var action = arguments[1];

	switch (action.type) {
		case 'SET_VISIBILITY_FILTER':
			return action.filter;

		default:
			return state;
	}
};

var _Redux = Redux;
var combineReducers = _Redux.combineReducers;

var todoApp = combineReducers({
	// Short:
	todos: todos,
	visibilityFilter: visibilityFilter

	// Long:
	/* todos: todos,
 /* visibilityFilter: visibilityFilter
 */
});

var _React = React;
var Component = _React.Component;

var Todo = function Todo(_ref) {
	var onClick = _ref.onClick;
	var completed = _ref.completed;
	var text = _ref.text;
	return React.createElement(
		'li',
		{
			onClick: onClick,
			style: {
				textDecoration: completed ? 'line-through' : 'none'
			}
		},
		text
	);
};

var TodoList = function TodoList(_ref2) {
	var todos = _ref2.todos;
	var onTodoClick = _ref2.onTodoClick;
	return React.createElement(
		'ul',
		null,
		todos.map(function (todo) {
			return React.createElement(Todo, _extends({
				key: todo.id
			}, todo, {
				onClick: function onClick() {
					return onTodoClick(todo.id);
				}
			}));
		})
	);
};

var Link = function Link(_ref3) {
	var active = _ref3.active;
	var children = _ref3.children;
	var _onClick = _ref3.onClick;

	if (active) {
		return React.createElement(
			'span',
			null,
			children
		);
	}
	return React.createElement(
		'a',
		{ href: '#',
			onClick: function onClick(e) {
				e.preventDefault();
				_onClick();
			}
		},
		children
	);
};

var FilterLink = (function (_Component) {
	_inherits(FilterLink, _Component);

	function FilterLink() {
		_classCallCheck(this, FilterLink);

		return _possibleConstructorReturn(this, Object.getPrototypeOf(FilterLink).apply(this, arguments));
	}

	_createClass(FilterLink, [{
		key: 'componentdidMount',
		value: function componentdidMount() {
			var _this2 = this;

			var store = this.context.store;

			this.unsubscribe = store.subscribe(function () {
				return _this2.forceUpdate();
			});
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this.unsubscribe();
		}
	}, {
		key: 'render',
		value: function render() {
			var props = this.props;
			var store = this.context.store;

			var state = store.getState();

			return React.createElement(
				Link,
				{
					active: props.filter === state.visibilityFilter,
					onClick: function onClick() {
						return store.dispatch({
							type: 'SET_VISIBILITY_FILTER',
							filter: props.filter
						});
					}
				},
				props.children
			);
		}
	}]);

	return FilterLink;
})(Component);

;
FilterLink.contextTypes = {
	store: React.PropTypes.object
};

var Footer = function Footer() {
	return React.createElement(
		'p',
		null,
		'Show:',
		' ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_ALL'
			},
			'All'
		),
		', ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_ACTIVE'
			},
			'Active'
		),
		', ',
		React.createElement(
			FilterLink,
			{
				filter: 'SHOW_COMPLETED'
			},
			'Completed'
		)
	);
};

var AddTodo = function AddTodo(props, _ref4) {
	var store = _ref4.store;

	var input = undefined;

	return React.createElement(
		'div',
		null,
		React.createElement('input', { ref: function ref(node) {
				input = node;
			} }),
		React.createElement(
			'button',
			{ onClick: function onClick() {
					store.dispatch({
						type: 'ADD_TODO',
						id: nextTodoId++,
						text: input.value
					});
					input.value = '';
				} },
			'Add Todo'
		)
	);
};
AddTodo.contextTypes = {
	store: React.PropTypes.object
};

var getVisibleTodos = function getVisibleTodos(todos, filter) {
	switch (filter) {
		case 'SHOW_ALL':
			return todos;

		case 'SHOW_COMPLETED':
			return todos.filter(function (t) {
				return t.completed;
			});

		case 'SHOW_ACTIVE':
			return todos.filter(function (t) {
				return !t.completed;
			});
	}
};

var mapStateToProps = function mapStateToProps(state) {
	return {
		todos: getVisibleTodos(state.todos, state.visibilityFilter)
	};
};

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	return {
		onTodoClick: function onTodoClick(id) {
			dispatch({
				type: 'TOGGLE_TODO',
				id: id
			});
		}
	};
};

var _ReactRedux = ReactRedux;
var connect = _ReactRedux.connect;
// ES6  via babel: import { connect } from 'react-redux';

var VisibleTodoList = connect(mapStateToProps, mapDispatchToProps)(TodoList);

var nextTodoId = 0;

var TodoApp = function TodoApp() {
	return React.createElement(
		'div',
		null,
		React.createElement(AddTodo, null),
		React.createElement(VisibleTodoList, null),
		React.createElement(Footer, null)
	);
};

var _ReactRedux2 = ReactRedux;
var Provider = _ReactRedux2.Provider;
// ES6  via babel: import { Provider } from 'react-redux';
// ES5: var Provider = require('react-redux').Provider;

var _Redux2 = Redux;
var createStore = _Redux2.createStore;

ReactDOM.render(React.createElement(
	Provider,
	{ store: createStore(todoApp) },
	React.createElement(TodoApp, null)
), document.getElementById('root'));

},{"deep-freeze-strict":1,"expect":7}]},{},[13])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZGVlcC1mcmVlemUtc3RyaWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V4cGVjdC9saWIvRXhwZWN0YXRpb24uanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L2xpYi9TcHlVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL1Rlc3RVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3QvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V4cGVjdC9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9leHBlY3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L25vZGVfbW9kdWxlcy9pcy1yZWdleHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXhwZWN0L25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcyIsInNyYy8xN19HZW5lcmF0aW5nX0NvbnRhaW5lcnNfd2l0aF9jb25uZWN0KCkvbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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SUFDRixDQUFDLENBQUE7R0FDRjtFQUNELENBQUM7Q0FDRixDQUFDOztrQkFFa0IsVUFBVTtJQUF0QixPQUFPLGVBQVAsT0FBTzs7O0FBR2YsSUFBTSxlQUFlLEdBQUcsT0FBTyxDQUM5QixlQUFlLEVBQ2Ysa0JBQWtCLENBQ2xCLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRVosSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDOztBQUVuQixJQUFNLE9BQU8sR0FBRyxTQUFWLE9BQU87UUFDWjs7O0VBQ0Msb0JBQUMsT0FBTyxPQUFHO0VBQ1gsb0JBQUMsZUFBZSxPQUFHO0VBQ25CLG9CQUFDLE1BQU0sT0FBRztFQUNMO0NBQ04sQ0FBQzs7bUJBRW1CLFVBQVU7SUFBdkIsUUFBUSxnQkFBUixRQUFROzs7O2NBSVEsS0FBSztJQUFyQixXQUFXLFdBQVgsV0FBVzs7QUFFbkIsUUFBUSxDQUFDLE1BQU0sQ0FDZDtBQUFDLFNBQVE7R0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLE9BQU8sQ0FBQyxBQUFDO0NBQ3JDLG9CQUFDLE9BQU8sT0FBRztDQUNELEVBQ1gsUUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FDL0IsQ0FBQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZXBGcmVlemUgKG8pIHtcbiAgT2JqZWN0LmZyZWV6ZShvKTtcblxuICB2YXIgb0lzRnVuY3Rpb24gPSB0eXBlb2YgbyA9PT0gXCJmdW5jdGlvblwiO1xuICB2YXIgaGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmIChoYXNPd25Qcm9wLmNhbGwobywgcHJvcClcbiAgICAmJiAob0lzRnVuY3Rpb24gPyBwcm9wICE9PSAnY2FsbGVyJyAmJiBwcm9wICE9PSAnY2FsbGVlJyAmJiBwcm9wICE9PSAnYXJndW1lbnRzJyA6IHRydWUgKVxuICAgICYmIG9bcHJvcF0gIT09IG51bGxcbiAgICAmJiAodHlwZW9mIG9bcHJvcF0gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9bcHJvcF0gPT09IFwiZnVuY3Rpb25cIilcbiAgICAmJiAhT2JqZWN0LmlzRnJvemVuKG9bcHJvcF0pKSB7XG4gICAgICBkZWVwRnJlZXplKG9bcHJvcF0pO1xuICAgIH1cbiAgfSk7XG4gIFxuICByZXR1cm4gbztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX2lzUmVnZXhwID0gcmVxdWlyZSgnaXMtcmVnZXhwJyk7XG5cbnZhciBfaXNSZWdleHAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNSZWdleHApO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5cbnZhciBfYXNzZXJ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydCk7XG5cbnZhciBfU3B5VXRpbHMgPSByZXF1aXJlKCcuL1NweVV0aWxzJyk7XG5cbnZhciBfVGVzdFV0aWxzID0gcmVxdWlyZSgnLi9UZXN0VXRpbHMnKTtcblxuLyoqXG4gKiBBbiBFeHBlY3RhdGlvbiBpcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGFzc2VydGlvbiB0aGF0IGFsbG93cyBpdCB0byBiZSB3cml0dGVuXG4gKiBpbiBhIG1vcmUgbmF0dXJhbCBzdHlsZSwgd2l0aG91dCB0aGUgbmVlZCB0byByZW1lbWJlciB0aGUgb3JkZXIgb2YgYXJndW1lbnRzLlxuICogVGhpcyBoZWxwcyBwcmV2ZW50IHlvdSBmcm9tIG1ha2luZyBtaXN0YWtlcyB3aGVuIHdyaXRpbmcgdGVzdHMuXG4gKi9cblxudmFyIEV4cGVjdGF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXhwZWN0YXRpb24oYWN0dWFsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4cGVjdGF0aW9uKTtcblxuICAgIHRoaXMuYWN0dWFsID0gYWN0dWFsO1xuXG4gICAgaWYgKF9UZXN0VXRpbHMuaXNGdW5jdGlvbihhY3R1YWwpKSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5hcmdzID0gW107XG4gICAgfVxuICB9XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvRXhpc3QgPSBmdW5jdGlvbiB0b0V4aXN0KG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHRoaXMuYWN0dWFsLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBleGlzdCcsIHRoaXMuYWN0dWFsKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b05vdEV4aXN0ID0gZnVuY3Rpb24gdG9Ob3RFeGlzdChtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSghdGhpcy5hY3R1YWwsIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIG5vdCBleGlzdCcsIHRoaXMuYWN0dWFsKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0JlID0gZnVuY3Rpb24gdG9CZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odGhpcy5hY3R1YWwgPT09IHZhbHVlLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBiZSAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9Ob3RCZSA9IGZ1bmN0aW9uIHRvTm90QmUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHRoaXMuYWN0dWFsICE9PSB2YWx1ZSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gbm90IGJlICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0VxdWFsID0gZnVuY3Rpb24gdG9FcXVhbCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHRyeSB7XG4gICAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9kZWVwRXF1YWwyWydkZWZhdWx0J10odGhpcy5hY3R1YWwsIHZhbHVlKSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gZXF1YWwgJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRoZXNlIGF0dHJpYnV0ZXMgYXJlIGNvbnN1bWVkIGJ5IE1vY2hhIHRvIHByb2R1Y2UgYSBkaWZmIG91dHB1dC5cbiAgICAgIGUuc2hvd0RpZmYgPSB0cnVlO1xuICAgICAgZS5hY3R1YWwgPSB0aGlzLmFjdHVhbDtcbiAgICAgIGUuZXhwZWN0ZWQgPSB2YWx1ZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvTm90RXF1YWwgPSBmdW5jdGlvbiB0b05vdEVxdWFsKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSghX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXSh0aGlzLmFjdHVhbCwgdmFsdWUpLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBub3QgZXF1YWwgJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvVGhyb3cgPSBmdW5jdGlvbiB0b1Rocm93KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzRnVuY3Rpb24odGhpcy5hY3R1YWwpLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9UaHJvdygpIG11c3QgYmUgYSBmdW5jdGlvbiwgJXMgd2FzIGdpdmVuJywgdGhpcy5hY3R1YWwpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmZ1bmN0aW9uVGhyb3dzKHRoaXMuYWN0dWFsLCB0aGlzLmNvbnRleHQsIHRoaXMuYXJncywgdmFsdWUpLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byB0aHJvdyAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSB8fCAnYW4gZXJyb3InKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b05vdFRocm93ID0gZnVuY3Rpb24gdG9Ob3RUaHJvdyh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKHRoaXMuYWN0dWFsKSwgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvTm90VGhyb3coKSBtdXN0IGJlIGEgZnVuY3Rpb24sICVzIHdhcyBnaXZlbicsIHRoaXMuYWN0dWFsKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oIV9UZXN0VXRpbHMuZnVuY3Rpb25UaHJvd3ModGhpcy5hY3R1YWwsIHRoaXMuY29udGV4dCwgdGhpcy5hcmdzLCB2YWx1ZSksIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIG5vdCB0aHJvdyAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSB8fCAnYW4gZXJyb3InKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0JlQSA9IGZ1bmN0aW9uIHRvQmVBKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzRnVuY3Rpb24odmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IGluIHRvQmVBKHZhbHVlKSBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0EodGhpcy5hY3R1YWwsIHZhbHVlKSwgbWVzc2FnZSB8fCAnRXhwZWN0ZWQgJXMgdG8gYmUgYSAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9Ob3RCZUEgPSBmdW5jdGlvbiB0b05vdEJlQSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBpbiB0b05vdEJlQSh2YWx1ZSkgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKCFfVGVzdFV0aWxzLmlzQSh0aGlzLmFjdHVhbCwgdmFsdWUpLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBiZSBhICVzJywgdGhpcy5hY3R1YWwsIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b01hdGNoID0gZnVuY3Rpb24gdG9NYXRjaChwYXR0ZXJuLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0eXBlb2YgdGhpcy5hY3R1YWwgPT09ICdzdHJpbmcnLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkudG9NYXRjaCgpIG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX2lzUmVnZXhwMlsnZGVmYXVsdCddKHBhdHRlcm4pLCAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBpbiB0b01hdGNoKHZhbHVlKSBtdXN0IGJlIGEgUmVnRXhwJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHBhdHRlcm4udGVzdCh0aGlzLmFjdHVhbCksIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIG1hdGNoICVzJywgdGhpcy5hY3R1YWwsIHBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvTm90TWF0Y2ggPSBmdW5jdGlvbiB0b05vdE1hdGNoKHBhdHRlcm4sIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHR5cGVvZiB0aGlzLmFjdHVhbCA9PT0gJ3N0cmluZycsICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b05vdE1hdGNoKCkgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfaXNSZWdleHAyWydkZWZhdWx0J10ocGF0dGVybiksICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IGluIHRvTm90TWF0Y2godmFsdWUpIG11c3QgYmUgYSBSZWdFeHAnKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oIXBhdHRlcm4udGVzdCh0aGlzLmFjdHVhbCksIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIG5vdCBtYXRjaCAlcycsIHRoaXMuYWN0dWFsLCBwYXR0ZXJuKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0JlTGVzc1RoYW4gPSBmdW5jdGlvbiB0b0JlTGVzc1RoYW4odmFsdWUsIG1lc3NhZ2UpIHtcbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHR5cGVvZiB0aGlzLmFjdHVhbCA9PT0gJ251bWJlcicsICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b0JlTGVzc1RoYW4oKSBtdXN0IGJlIGEgbnVtYmVyJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IGluIHRvQmVMZXNzVGhhbih2YWx1ZSkgbXVzdCBiZSBhIG51bWJlcicpO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSh0aGlzLmFjdHVhbCA8IHZhbHVlLCBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBiZSBsZXNzIHRoYW4gJXMnLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLnRvQmVHcmVhdGVyVGhhbiA9IGZ1bmN0aW9uIHRvQmVHcmVhdGVyVGhhbih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odHlwZW9mIHRoaXMuYWN0dWFsID09PSAnbnVtYmVyJywgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvQmVHcmVhdGVyVGhhbigpIG11c3QgYmUgYSBudW1iZXInKTtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10odHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgaW4gdG9CZUdyZWF0ZXJUaGFuKHZhbHVlKSBtdXN0IGJlIGEgbnVtYmVyJyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHRoaXMuYWN0dWFsID4gdmFsdWUsIG1lc3NhZ2UgfHwgJ0V4cGVjdGVkICVzIHRvIGJlIGdyZWF0ZXIgdGhhbiAlcycsIHRoaXMuYWN0dWFsLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9JbmNsdWRlID0gZnVuY3Rpb24gdG9JbmNsdWRlKHZhbHVlLCBjb21wYXJhdG9yLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzQXJyYXkodGhpcy5hY3R1YWwpIHx8IHR5cGVvZiB0aGlzLmFjdHVhbCA9PT0gJ3N0cmluZycsICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b0luY2x1ZGUoKSBtdXN0IGJlIGFuIGFycmF5IG9yIGEgc3RyaW5nJyk7XG5cbiAgICBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtZXNzYWdlID0gY29tcGFyYXRvcjtcbiAgICAgIGNvbXBhcmF0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBpbmNsdWRlICVzJztcblxuICAgIGlmIChfVGVzdFV0aWxzLmlzQXJyYXkodGhpcy5hY3R1YWwpKSB7XG4gICAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuYXJyYXlDb250YWlucyh0aGlzLmFjdHVhbCwgdmFsdWUsIGNvbXBhcmF0b3IpLCBtZXNzYWdlLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKF9UZXN0VXRpbHMuc3RyaW5nQ29udGFpbnModGhpcy5hY3R1YWwsIHZhbHVlKSwgbWVzc2FnZSwgdGhpcy5hY3R1YWwsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUudG9FeGNsdWRlID0gZnVuY3Rpb24gdG9FeGNsdWRlKHZhbHVlLCBjb21wYXJhdG9yLCBtZXNzYWdlKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzQXJyYXkodGhpcy5hY3R1YWwpIHx8IHR5cGVvZiB0aGlzLmFjdHVhbCA9PT0gJ3N0cmluZycsICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b0V4Y2x1ZGUoKSBtdXN0IGJlIGFuIGFycmF5IG9yIGEgc3RyaW5nJyk7XG5cbiAgICBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtZXNzYWdlID0gY29tcGFyYXRvcjtcbiAgICAgIGNvbXBhcmF0b3IgPSBudWxsO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdFeHBlY3RlZCAlcyB0byBleGNsdWRlICVzJztcblxuICAgIGlmIChfVGVzdFV0aWxzLmlzQXJyYXkodGhpcy5hY3R1YWwpKSB7XG4gICAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKCFfVGVzdFV0aWxzLmFycmF5Q29udGFpbnModGhpcy5hY3R1YWwsIHZhbHVlLCBjb21wYXJhdG9yKSwgbWVzc2FnZSwgdGhpcy5hY3R1YWwsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2Fzc2VydDJbJ2RlZmF1bHQnXSghX1Rlc3RVdGlscy5zdHJpbmdDb250YWlucyh0aGlzLmFjdHVhbCwgdmFsdWUpLCBtZXNzYWdlLCB0aGlzLmFjdHVhbCwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0hhdmVCZWVuQ2FsbGVkID0gZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZChtZXNzYWdlKSB7XG4gICAgdmFyIHNweSA9IHRoaXMuYWN0dWFsO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfU3B5VXRpbHMuaXNTcHkoc3B5KSwgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvSGF2ZUJlZW5DYWxsZWQoKSBtdXN0IGJlIGEgc3B5Jyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHNweS5jYWxscy5sZW5ndGggPiAwLCBtZXNzYWdlIHx8ICdzcHkgd2FzIG5vdCBjYWxsZWQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b0hhdmVCZWVuQ2FsbGVkV2l0aCA9IGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWRXaXRoKCkge1xuICAgIHZhciBzcHkgPSB0aGlzLmFjdHVhbDtcblxuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1NweVV0aWxzLmlzU3B5KHNweSksICdUaGUgXCJhY3R1YWxcIiBhcmd1bWVudCBpbiBleHBlY3QoYWN0dWFsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgpIG11c3QgYmUgYSBzcHknKTtcblxuICAgIHZhciBleHBlY3RlZEFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShzcHkuY2FsbHMuc29tZShmdW5jdGlvbiAoY2FsbCkge1xuICAgICAgcmV0dXJuIF9kZWVwRXF1YWwyWydkZWZhdWx0J10oY2FsbC5hcmd1bWVudHMsIGV4cGVjdGVkQXJncyk7XG4gICAgfSksICdzcHkgd2FzIG5ldmVyIGNhbGxlZCB3aXRoICVzJywgZXhwZWN0ZWRBcmdzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS50b05vdEhhdmVCZWVuQ2FsbGVkID0gZnVuY3Rpb24gdG9Ob3RIYXZlQmVlbkNhbGxlZChtZXNzYWdlKSB7XG4gICAgdmFyIHNweSA9IHRoaXMuYWN0dWFsO1xuXG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfU3B5VXRpbHMuaXNTcHkoc3B5KSwgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLnRvTm90SGF2ZUJlZW5DYWxsZWQoKSBtdXN0IGJlIGEgc3B5Jyk7XG5cbiAgICBfYXNzZXJ0MlsnZGVmYXVsdCddKHNweS5jYWxscy5sZW5ndGggPT09IDAsIG1lc3NhZ2UgfHwgJ3NweSB3YXMgbm90IHN1cHBvc2VkIHRvIGJlIGNhbGxlZCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLndpdGhDb250ZXh0ID0gZnVuY3Rpb24gd2l0aENvbnRleHQoY29udGV4dCkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKHRoaXMuYWN0dWFsKSwgJ1RoZSBcImFjdHVhbFwiIGFyZ3VtZW50IGluIGV4cGVjdChhY3R1YWwpLndpdGhDb250ZXh0KCkgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXhwZWN0YXRpb24ucHJvdG90eXBlLndpdGhBcmdzID0gZnVuY3Rpb24gd2l0aEFyZ3MoKSB7XG4gICAgX2Fzc2VydDJbJ2RlZmF1bHQnXShfVGVzdFV0aWxzLmlzRnVuY3Rpb24odGhpcy5hY3R1YWwpLCAnVGhlIFwiYWN0dWFsXCIgYXJndW1lbnQgaW4gZXhwZWN0KGFjdHVhbCkud2l0aEFyZ3MoKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB0aGlzLmFyZ3MgPSB0aGlzLmFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEV4cGVjdGF0aW9uO1xufSkoKTtcblxudmFyIGFsaWFzZXMgPSB7XG4gIHRvQmVBbjogJ3RvQmVBJyxcbiAgdG9Ob3RCZUFuOiAndG9Ob3RCZUEnLFxuICB0b0JlVHJ1dGh5OiAndG9FeGlzdCcsXG4gIHRvQmVGYWxzeTogJ3RvTm90RXhpc3QnLFxuICB0b0JlRmV3ZXJUaGFuOiAndG9CZUxlc3NUaGFuJyxcbiAgdG9CZU1vcmVUaGFuOiAndG9CZUdyZWF0ZXJUaGFuJyxcbiAgdG9Db250YWluOiAndG9JbmNsdWRlJyxcbiAgdG9Ob3RDb250YWluOiAndG9FeGNsdWRlJ1xufTtcblxuZm9yICh2YXIgYWxpYXMgaW4gYWxpYXNlcykge1xuICBFeHBlY3RhdGlvbi5wcm90b3R5cGVbYWxpYXNdID0gRXhwZWN0YXRpb24ucHJvdG90eXBlW2FsaWFzZXNbYWxpYXNdXTtcbn1leHBvcnRzWydkZWZhdWx0J10gPSBFeHBlY3RhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlU3B5ID0gY3JlYXRlU3B5O1xuZXhwb3J0cy5zcHlPbiA9IHNweU9uO1xuZXhwb3J0cy5pc1NweSA9IGlzU3B5O1xuZXhwb3J0cy5yZXN0b3JlU3BpZXMgPSByZXN0b3JlU3BpZXM7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuXG52YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NlcnQpO1xuXG52YXIgX1Rlc3RVdGlscyA9IHJlcXVpcmUoJy4vVGVzdFV0aWxzJyk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgc3BpZXMgPSBbXTtcblxuZnVuY3Rpb24gY3JlYXRlU3B5KGZuKSB7XG4gIHZhciByZXN0b3JlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbm9vcCA6IGFyZ3VtZW50c1sxXTtcblxuICBpZiAoZm4gPT0gbnVsbCkgZm4gPSBub29wO1xuXG4gIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKGZuKSwgJ2NyZWF0ZVNweSBuZWVkcyBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIHRhcmdldEZuID0gdW5kZWZpbmVkLFxuICAgICAgdGhyb3duVmFsdWUgPSB1bmRlZmluZWQsXG4gICAgICByZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcblxuICB2YXIgc3B5ID0gZnVuY3Rpb24gc3B5KCkge1xuICAgIHNweS5jYWxscy5wdXNoKHtcbiAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICBhcmd1bWVudHM6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcbiAgICB9KTtcblxuICAgIGlmICh0YXJnZXRGbikgcmV0dXJuIHRhcmdldEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGhyb3duVmFsdWUpIHRocm93IHRocm93blZhbHVlO1xuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIHNweS5jYWxscyA9IFtdO1xuXG4gIHNweS5hbmRDYWxsID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdGFyZ2V0Rm4gPSBmbjtcbiAgICByZXR1cm4gc3B5O1xuICB9O1xuXG4gIHNweS5hbmRDYWxsVGhyb3VnaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3B5LmFuZENhbGwoZm4pO1xuICB9O1xuXG4gIHNweS5hbmRUaHJvdyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB0aHJvd25WYWx1ZSA9IG9iamVjdDtcbiAgICByZXR1cm4gc3B5O1xuICB9O1xuXG4gIHNweS5hbmRSZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm5WYWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBzcHk7XG4gIH07XG5cbiAgc3B5LmdldExhc3RDYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzcHkuY2FsbHNbc3B5LmNhbGxzLmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIHNweS5yZXN0b3JlID0gc3B5LmRlc3Ryb3kgPSByZXN0b3JlO1xuXG4gIHNweS5fX2lzU3B5ID0gdHJ1ZTtcblxuICBzcGllcy5wdXNoKHNweSk7XG5cbiAgcmV0dXJuIHNweTtcbn1cblxuZnVuY3Rpb24gc3B5T24ob2JqZWN0LCBtZXRob2ROYW1lKSB7XG4gIHZhciBvcmlnaW5hbCA9IG9iamVjdFttZXRob2ROYW1lXTtcblxuICBpZiAoIWlzU3B5KG9yaWdpbmFsKSkge1xuICAgIF9hc3NlcnQyWydkZWZhdWx0J10oX1Rlc3RVdGlscy5pc0Z1bmN0aW9uKG9yaWdpbmFsKSwgJ0Nhbm5vdCBzcHlPbiB0aGUgJXMgcHJvcGVydHk7IGl0IGlzIG5vdCBhIGZ1bmN0aW9uJywgbWV0aG9kTmFtZSk7XG5cbiAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBjcmVhdGVTcHkob3JpZ2luYWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IG9yaWdpbmFsO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFttZXRob2ROYW1lXTtcbn1cblxuZnVuY3Rpb24gaXNTcHkob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll9faXNTcHkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTcGllcygpIHtcbiAgZm9yICh2YXIgaSA9IHNwaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgc3BpZXNbaV0ucmVzdG9yZSgpO1xuICB9c3BpZXMgPSBbXTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmZ1bmN0aW9uVGhyb3dzID0gZnVuY3Rpb25UaHJvd3M7XG5leHBvcnRzLmFycmF5Q29udGFpbnMgPSBhcnJheUNvbnRhaW5zO1xuZXhwb3J0cy5zdHJpbmdDb250YWlucyA9IHN0cmluZ0NvbnRhaW5zO1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzQSA9IGlzQTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2RlZXBFcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcblxudmFyIF9kZWVwRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcEVxdWFsKTtcblxudmFyIF9pc1JlZ2V4cCA9IHJlcXVpcmUoJ2lzLXJlZ2V4cCcpO1xuXG52YXIgX2lzUmVnZXhwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUmVnZXhwKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZ1bmN0aW9uIHRocm93cyB0aGUgZ2l2ZW4gdmFsdWVcbiAqIHdoZW4gaW52b2tlZC4gVGhlIHZhbHVlIG1heSBiZTpcbiAqXG4gKiAtIHVuZGVmaW5lZCwgdG8gbWVyZWx5IGFzc2VydCB0aGVyZSB3YXMgYSB0aHJvd1xuICogLSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBmb3IgY29tcGFyaW5nIHVzaW5nIGluc3RhbmNlb2ZcbiAqIC0gYSByZWd1bGFyIGV4cHJlc3Npb24sIHRvIGNvbXBhcmUgd2l0aCB0aGUgZXJyb3IgbWVzc2FnZVxuICogLSBhIHN0cmluZywgdG8gZmluZCBpbiB0aGUgZXJyb3IgbWVzc2FnZVxuICovXG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhyb3dzKGZuLCBjb250ZXh0LCBhcmdzLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBlcnJvciBpbnN0YW5jZW9mIHZhbHVlKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCBlcnJvcjtcblxuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChfaXNSZWdleHAyWydkZWZhdWx0J10odmFsdWUpICYmIHZhbHVlLnRlc3QoZXJyb3IubWVzc2FnZSkpIHJldHVybiB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBtZXNzYWdlLmluZGV4T2YodmFsdWUpICE9PSAtMSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYXJyYXkgY29udGFpbnMgdGhlIHZhbHVlLCBmYWxzZVxuICogb3RoZXJ3aXNlLiBUaGUgY29tcGFyYXRvciBmdW5jdGlvbiBtdXN0IHJldHVybiBmYWxzZSB0b1xuICogaW5kaWNhdGUgYSBub24tbWF0Y2guXG4gKi9cblxuZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgaWYgKGNvbXBhcmF0b3IgPT0gbnVsbCkgY29tcGFyYXRvciA9IF9kZWVwRXF1YWwyWydkZWZhdWx0J107XG5cbiAgcmV0dXJuIGFycmF5LnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gY29tcGFyYXRvcihpdGVtLCB2YWx1ZSkgIT09IGZhbHNlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyB0aGUgdmFsdWUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdDb250YWlucyhzdHJpbmcsIHZhbHVlKSB7XG4gIHJldHVybiBzdHJpbmcuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqZWN0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iamVjdCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZW9mIHZhbHVlXG4gKiBvciBpdHMgdHlwZW9mIGlzIHRoZSBnaXZlbiB2YWx1ZS5cbiAqL1xuXG5mdW5jdGlvbiBpc0Eob2JqZWN0LCB2YWx1ZSkge1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB2YWx1ZTtcblxuICBpZiAodmFsdWUgPT09ICdhcnJheScpIHJldHVybiBBcnJheS5pc0FycmF5KG9iamVjdCk7XG5cbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09IHZhbHVlO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX29iamVjdEluc3BlY3QgPSByZXF1aXJlKCdvYmplY3QtaW5zcGVjdCcpO1xuXG52YXIgX29iamVjdEluc3BlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0SW5zcGVjdCk7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2VGb3JtYXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGV4dHJhQXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBleHRyYUFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGNvbmRpdGlvbikgcmV0dXJuO1xuXG4gIHZhciBpbmRleCA9IDA7XG5cbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfb2JqZWN0SW5zcGVjdDJbJ2RlZmF1bHQnXShleHRyYUFyZ3NbaW5kZXgrK10pO1xuICB9KSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGFzc2VydDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0V4cGVjdGF0aW9uID0gcmVxdWlyZSgnLi9FeHBlY3RhdGlvbicpO1xuXG52YXIgX0V4cGVjdGF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V4cGVjdGF0aW9uKTtcblxudmFyIEV4dGVuc2lvbnMgPSBbXTtcblxuZnVuY3Rpb24gZXh0ZW5kKGV4dGVuc2lvbikge1xuICBpZiAoRXh0ZW5zaW9ucy5pbmRleE9mKGV4dGVuc2lvbikgPT09IC0xKSB7XG4gICAgRXh0ZW5zaW9ucy5wdXNoKGV4dGVuc2lvbik7XG5cbiAgICBmb3IgKHZhciBwIGluIGV4dGVuc2lvbikge1xuICAgICAgaWYgKGV4dGVuc2lvbi5oYXNPd25Qcm9wZXJ0eShwKSkgX0V4cGVjdGF0aW9uMlsnZGVmYXVsdCddLnByb3RvdHlwZVtwXSA9IGV4dGVuc2lvbltwXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZXh0ZW5kO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfRXhwZWN0YXRpb24gPSByZXF1aXJlKCcuL0V4cGVjdGF0aW9uJyk7XG5cbnZhciBfRXhwZWN0YXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXhwZWN0YXRpb24pO1xuXG52YXIgX1NweVV0aWxzID0gcmVxdWlyZSgnLi9TcHlVdGlscycpO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5cbnZhciBfYXNzZXJ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2VydCk7XG5cbnZhciBfZXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcblxudmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblxuZnVuY3Rpb24gZXhwZWN0KGFjdHVhbCkge1xuICByZXR1cm4gbmV3IF9FeHBlY3RhdGlvbjJbJ2RlZmF1bHQnXShhY3R1YWwpO1xufVxuXG5leHBlY3QuY3JlYXRlU3B5ID0gX1NweVV0aWxzLmNyZWF0ZVNweTtcbmV4cGVjdC5zcHlPbiA9IF9TcHlVdGlscy5zcHlPbjtcbmV4cGVjdC5pc1NweSA9IF9TcHlVdGlscy5pc1NweTtcbmV4cGVjdC5yZXN0b3JlU3BpZXMgPSBfU3B5VXRpbHMucmVzdG9yZVNwaWVzO1xuZXhwZWN0LmFzc2VydCA9IF9hc3NlcnQyWydkZWZhdWx0J107XG5leHBlY3QuZXh0ZW5kID0gX2V4dGVuZDJbJ2RlZmF1bHQnXTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZXhwZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmUpIHtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5zcGVjdF8gKG9iaiwgb3B0cywgZGVwdGgsIHNlZW4pIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBcbiAgICB2YXIgbWF4RGVwdGggPSBvcHRzLmRlcHRoID09PSB1bmRlZmluZWQgPyA1IDogb3B0cy5kZXB0aDtcbiAgICBpZiAoZGVwdGggPT09IHVuZGVmaW5lZCkgZGVwdGggPSAwO1xuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDBcbiAgICAmJiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuICdbT2JqZWN0XSc7XG4gICAgfVxuICAgIFxuICAgIGlmIChzZWVuID09PSB1bmRlZmluZWQpIHNlZW4gPSBbXTtcbiAgICBlbHNlIGlmIChpbmRleE9mKHNlZW4sIG9iaikgPj0gMCkge1xuICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBpbnNwZWN0ICh2YWx1ZSwgZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgc2VlbiA9IHNlZW4uc2xpY2UoKTtcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zcGVjdF8odmFsdWUsIG9wdHMsIGRlcHRoICsgMSwgc2Vlbik7XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmopO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZU9mKG9iaik7XG4gICAgICAgIHJldHVybiAnW0Z1bmN0aW9uJyArIChuYW1lID8gJzogJyArIG5hbWUgOiAnJykgKyAnXSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N5bWJvbChvYmopKSB7XG4gICAgICAgIHZhciBzeW1TdHJpbmcgPSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnID8gJ09iamVjdCgnICsgc3ltU3RyaW5nICsgJyknIDogc3ltU3RyaW5nO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0VsZW1lbnQob2JqKSkge1xuICAgICAgICB2YXIgcyA9ICc8JyArIFN0cmluZyhvYmoubm9kZU5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzICs9ICcgJyArIGF0dHJzW2ldLm5hbWUgKyAnPVwiJyArIHF1b3RlKGF0dHJzW2ldLnZhbHVlKSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSAnPic7XG4gICAgICAgIGlmIChvYmouY2hpbGROb2RlcyAmJiBvYmouY2hpbGROb2Rlcy5sZW5ndGgpIHMgKz0gJy4uLic7XG4gICAgICAgIHMgKz0gJzwvJyArIFN0cmluZyhvYmoubm9kZU5hbWUpLnRvTG93ZXJDYXNlKCkgKyAnPic7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHJldHVybiAnW10nO1xuICAgICAgICB2YXIgeHMgPSBBcnJheShvYmoubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHhzW2ldID0gaGFzKG9iaiwgaSkgPyBpbnNwZWN0KG9ialtpXSwgb2JqKSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnWyAnICsgeHMuam9pbignLCAnKSArICcgXSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKCFoYXMob2JqLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKC9bXlxcdyRdLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGluc3BlY3Qoa2V5KSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGtleSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdbJyArIG9iaiArICddJztcbiAgICAgICAgcmV0dXJuICd7IFsnICsgb2JqICsgJ10gJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbnNwZWN0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFpc0RhdGUob2JqKSAmJiAhaXNSZWdFeHAob2JqKSkge1xuICAgICAgICB2YXIgeHMgPSBbXSwga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoL1teXFx3JF0vLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIHhzLnB1c2goaW5zcGVjdChrZXkpICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB4cy5wdXNoKGtleSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeHMubGVuZ3RoID09PSAwKSByZXR1cm4gJ3t9JztcbiAgICAgICAgcmV0dXJuICd7ICcgKyB4cy5qb2luKCcsICcpICsgJyB9JztcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gU3RyaW5nKG9iaik7XG59O1xuXG5mdW5jdGlvbiBxdW90ZSAocykge1xuICAgIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5IChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XScgfVxuZnVuY3Rpb24gaXNEYXRlIChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyB9XG5mdW5jdGlvbiBpc1JlZ0V4cCAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyB9XG5mdW5jdGlvbiBpc0Vycm9yIChvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEVycm9yXScgfVxuZnVuY3Rpb24gaXNTeW1ib2wgKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgU3ltYm9sXScgfVxuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gdGhpczsgfTtcbmZ1bmN0aW9uIGhhcyAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufVxuXG5mdW5jdGlvbiB0b1N0ciAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBuYW1lT2YgKGYpIHtcbiAgICBpZiAoZi5uYW1lKSByZXR1cm4gZi5uYW1lO1xuICAgIHZhciBtID0gZi50b1N0cmluZygpLm1hdGNoKC9eZnVuY3Rpb25cXHMqKFtcXHckXSspLyk7XG4gICAgaWYgKG0pIHJldHVybiBtWzFdO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCAoeCkge1xuICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgJiYgdHlwZW9mIHguZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nXG4gICAgO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0U3RyaW5nIChzdHIpIHtcbiAgICB2YXIgcyA9IHN0ci5yZXBsYWNlKC8oWydcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1tcXHgwMC1cXHgxZl0vZywgbG93Ynl0ZSk7XG4gICAgcmV0dXJuIFwiJ1wiICsgcyArIFwiJ1wiO1xuICAgIFxuICAgIGZ1bmN0aW9uIGxvd2J5dGUgKGMpIHtcbiAgICAgICAgdmFyIG4gPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHZhciB4ID0geyA4OiAnYicsIDk6ICd0JywgMTA6ICduJywgMTI6ICdmJywgMTM6ICdyJyB9W25dO1xuICAgICAgICBpZiAoeCkgcmV0dXJuICdcXFxcJyArIHg7XG4gICAgICAgIHJldHVybiAnXFxcXHgnICsgKG4gPCAweDEwID8gJzAnIDogJycpICsgbi50b1N0cmluZygxNik7XG4gICAgfVxufVxuIiwiLy8gVXNpbmcgYW4gRVM2IHRyYW5zcGlsZXIsIGxpa2UgYmFiZWwgXG5pbXBvcnQgZXhwZWN0IGZyb20gJ2V4cGVjdCc7XG5pbXBvcnQgZGVlcEZyZWV6ZSBmcm9tICdkZWVwLWZyZWV6ZS1zdHJpY3QnO1xuXG5jb25zdCB0b2RvID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcblx0c3dpdGNoKGFjdGlvbi50eXBlKSB7XG5cdFx0Y2FzZSAnQUREX1RPRE8nOlxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQ6IGFjdGlvbi5pZCxcblx0XHRcdFx0dGV4dDogYWN0aW9uLnRleHQsXG5cdFx0XHRcdGNvbXBsZXRlZDogZmFsc2Vcblx0XHRcdH07XG5cblx0XHRjYXNlICdUT0dHTEVfVE9ETyc6XHRcdFx0XG5cdFx0XHRpZihzdGF0ZS5pZCAhPT0gYWN0aW9uLmlkKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7ICdjb21wbGV0ZWQnOiAhc3RhdGUuY29tcGxldGVkIH0pO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBzdGF0ZTtcblx0fVxufTtcblxuXG5jb25zdCB0b2RvcyA9IChzdGF0ZSA9IFtdLCBhY3Rpb24pID0+IHtcblx0c3dpdGNoKGFjdGlvbi50eXBlKSB7XG5cdFx0Y2FzZSAnQUREX1RPRE8nOlxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0Li4uc3RhdGUsXG5cdFx0XHRcdHRvZG8odW5kZWZpbmVkLCBhY3Rpb24pXG5cdFx0XHRdO1xuXG5cdFx0Y2FzZSAnVE9HR0xFX1RPRE8nOlxuXHRcdFx0cmV0dXJuIHN0YXRlLm1hcCh0ID0+IHRvZG8odCwgYWN0aW9uKSk7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG59O1xuXG5jb25zdCB2aXNpYmlsaXR5RmlsdGVyID0gKFxuXHRzdGF0ZSA9ICdTSE9XX0FMTCcsXG5cdGFjdGlvblxuKSA9PiB7XG5cdHN3aXRjaChhY3Rpb24udHlwZSkge1xuXHRcdGNhc2UgJ1NFVF9WSVNJQklMSVRZX0ZJTFRFUic6XG5cdFx0XHRyZXR1cm4gYWN0aW9uLmZpbHRlcjtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn07XG5cblxuY29uc3QgeyBjb21iaW5lUmVkdWNlcnMgfSA9IFJlZHV4O1xuY29uc3QgdG9kb0FwcCA9IGNvbWJpbmVSZWR1Y2Vycyh7XG5cdC8vIFNob3J0OlxuXHR0b2Rvcyxcblx0dmlzaWJpbGl0eUZpbHRlclxuXG5cdC8vIExvbmc6XG5cdC8qIHRvZG9zOiB0b2Rvcyxcblx0LyogdmlzaWJpbGl0eUZpbHRlcjogdmlzaWJpbGl0eUZpbHRlclxuXHQqL1xufSk7XG5cbmNvbnN0IHsgQ29tcG9uZW50IH0gPSBSZWFjdDtcblxuY29uc3QgVG9kbyA9ICh7XG5cdG9uQ2xpY2ssXG5cdGNvbXBsZXRlZCxcblx0dGV4dFxufSkgPT4gKFxuXHQ8bGlcblx0XHRvbkNsaWNrPXtcblx0XHRcdG9uQ2xpY2tcblx0XHR9XG5cdFx0c3R5bGU9e3tcblx0XHRcdHRleHREZWNvcmF0aW9uOlxuXHRcdFx0XHRjb21wbGV0ZWQgP1xuXHRcdFx0XHRcdCdsaW5lLXRocm91Z2gnOlxuXHRcdFx0XHRcdCdub25lJ1xuXHRcdH19XG5cdD5cblx0XHR7dGV4dH1cblx0PC9saT5cbik7XG5cbmNvbnN0IFRvZG9MaXN0ID0gKHtcblx0dG9kb3MsXG5cdG9uVG9kb0NsaWNrXG59KSA9PiAoXG5cdDx1bD5cblx0XHR7dG9kb3MubWFwKHRvZG8gPT4gXG5cdFx0XHQ8VG9kb1xuXHRcdFx0XHRrZXk9e3RvZG8uaWR9XG5cdFx0XHRcdHsuLi50b2RvfVxuXHRcdFx0XHRvbkNsaWNrPXsoKSA9PiBvblRvZG9DbGljayh0b2RvLmlkKX1cblx0XHRcdC8+XG5cdFx0KX1cblx0PC91bD5cbik7XG5cbmNvbnN0IExpbmsgPSAoe1xuXHRhY3RpdmUsXG5cdGNoaWxkcmVuLFxuXHRvbkNsaWNrXG59KSA9PiB7XG5cdGlmKGFjdGl2ZSkge1xuXHRcdHJldHVybiA8c3Bhbj57Y2hpbGRyZW59PC9zcGFuPjtcblx0fVxuXHRyZXR1cm4gKFxuXHRcdDxhIGhyZWY9JyMnXG5cdFx0XHRvbkNsaWNrPXtlID0+IHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRvbkNsaWNrKCk7XG5cdFx0XHR9fVxuXHRcdD5cblx0XHRcdHtjaGlsZHJlbn1cblx0XHQ8L2E+XG5cdCk7XG59O1xuXG5jbGFzcyBGaWx0ZXJMaW5rIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29tcG9uZW50ZGlkTW91bnQoKSB7XG5cdFx0Y29uc3QgeyBzdG9yZSB9ID0gdGhpcy5jb250ZXh0O1xuXHRcdHRoaXMudW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUoKCkgPT5cblx0XHRcdHRoaXMuZm9yY2VVcGRhdGUoKVxuXHRcdCk7XG5cdH1cblxuXHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHR0aGlzLnVuc3Vic2NyaWJlKCk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuXHRcdGNvbnN0IHsgc3RvcmUgfSA9IHRoaXMuY29udGV4dDtcblx0XHRjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PExpbmsgXG5cdFx0XHRcdGFjdGl2ZT17XG5cdFx0XHRcdFx0cHJvcHMuZmlsdGVyID09PSBzdGF0ZS52aXNpYmlsaXR5RmlsdGVyXG5cdFx0XHRcdH1cblx0XHRcdFx0b25DbGljaz17KCkgPT5cblx0XHRcdFx0XHRzdG9yZS5kaXNwYXRjaCh7XG5cdFx0XHRcdFx0XHR0eXBlOiAnU0VUX1ZJU0lCSUxJVFlfRklMVEVSJyxcblx0XHRcdFx0XHRcdGZpbHRlcjogcHJvcHMuZmlsdGVyXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0PlxuXHRcdFx0e3Byb3BzLmNoaWxkcmVufVxuXHRcdFx0PC9MaW5rPlxuXHRcdClcblx0fVxufTtcbkZpbHRlckxpbmsuY29udGV4dFR5cGVzID0ge1xuXHRzdG9yZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdFxufTtcblxuY29uc3QgRm9vdGVyID0gKCkgPT4gKFxuXHQ8cD5cblx0XHRTaG93OlxuXHRcdHsnICd9XG5cdFx0PEZpbHRlckxpbmtcblx0XHRcdGZpbHRlcj0nU0hPV19BTEwnXG5cdFx0PlxuXHRcdFx0QWxsXG5cdFx0PC9GaWx0ZXJMaW5rPlxuXHRcdHsnLCAnfVxuXHRcdDxGaWx0ZXJMaW5rXG5cdFx0XHRmaWx0ZXI9J1NIT1dfQUNUSVZFJ1xuXHRcdD5cblx0XHRcdEFjdGl2ZVxuXHRcdDwvRmlsdGVyTGluaz5cblx0XHR7JywgJ31cblx0XHQ8RmlsdGVyTGlua1xuXHRcdFx0ZmlsdGVyPSdTSE9XX0NPTVBMRVRFRCdcblx0XHQ+XG5cdFx0XHRDb21wbGV0ZWRcblx0XHQ8L0ZpbHRlckxpbms+XG5cdDwvcD5cbik7XG5cbmNvbnN0IEFkZFRvZG8gPSAocHJvcHMsIHtcblx0c3RvcmVcbn0pID0+IHtcblx0bGV0IGlucHV0O1xuXG5cdHJldHVybiAoXG5cdFx0PGRpdj5cblx0XHRcdDxpbnB1dCByZWY9e25vZGUgPT4ge1xuXHRcdFx0XHRpbnB1dCA9IG5vZGU7XG5cdFx0XHR9fSAvPlxuXHRcdFx0PGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdHN0b3JlLmRpc3BhdGNoKHtcblx0XHRcdFx0XHR0eXBlOiAnQUREX1RPRE8nLFxuXHRcdFx0XHRcdGlkOiBuZXh0VG9kb0lkKyssXG5cdFx0XHRcdFx0dGV4dDogaW5wdXQudmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdFx0aW5wdXQudmFsdWUgPSAnJztcblx0XHRcdH19PlxuXHRcdFx0QWRkIFRvZG9cblx0XHRcdDwvYnV0dG9uPlxuXHRcdDwvZGl2PlxuXHQpO1xufTtcbkFkZFRvZG8uY29udGV4dFR5cGVzID0ge1xuXHRzdG9yZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdFxufTtcblxuY29uc3QgZ2V0VmlzaWJsZVRvZG9zID0gKFxuXHR0b2Rvcyxcblx0ZmlsdGVyXG4pID0+IHtcblx0c3dpdGNoKGZpbHRlcikge1xuXHRcdGNhc2UgJ1NIT1dfQUxMJzpcblx0XHRcdHJldHVybiB0b2RvcztcblxuXHRcdGNhc2UgJ1NIT1dfQ09NUExFVEVEJzpcblx0XHRcdHJldHVybiB0b2Rvcy5maWx0ZXIoXG5cdFx0XHRcdHQgPT4gdC5jb21wbGV0ZWRcblx0XHRcdCk7XG5cblx0XHRjYXNlICdTSE9XX0FDVElWRSc6XG5cdFx0XHRyZXR1cm4gdG9kb3MuZmlsdGVyKFxuXHRcdFx0XHR0ID0+ICF0LmNvbXBsZXRlZFxuXHRcdFx0KTtcblx0fVxufVxuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSAoc3RhdGUpID0+IHtcblx0cmV0dXJuIHtcblx0XHR0b2RvczogZ2V0VmlzaWJsZVRvZG9zKFxuXHRcdFx0c3RhdGUudG9kb3MsXG5cdFx0XHRzdGF0ZS52aXNpYmlsaXR5RmlsdGVyXG5cdFx0KVxuXHR9O1xufTtcblxuY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gKGRpc3BhdGNoKSA9PiB7XG5cdHJldHVybiB7XG5cdFx0b25Ub2RvQ2xpY2s6IChpZCkgPT4geyBcblx0XHRcdGRpc3BhdGNoKHtcblx0XHRcdFx0dHlwZTogJ1RPR0dMRV9UT0RPJyxcblx0XHRcdFx0aWRcblx0XHRcdH0pXG5cdFx0fVxuXHR9O1xufTtcblxuY29uc3QgeyBjb25uZWN0IH0gPSBSZWFjdFJlZHV4O1xuLy8gRVM2ICB2aWEgYmFiZWw6IGltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5cbmNvbnN0IFZpc2libGVUb2RvTGlzdCA9IGNvbm5lY3QoXG5cdG1hcFN0YXRlVG9Qcm9wcyxcblx0bWFwRGlzcGF0Y2hUb1Byb3BzXG4pKFRvZG9MaXN0KTtcblxubGV0IG5leHRUb2RvSWQgPSAwO1xuXG5jb25zdCBUb2RvQXBwID0gKCkgPT4gKFx0XG5cdDxkaXY+XG5cdFx0PEFkZFRvZG8gLz5cblx0XHQ8VmlzaWJsZVRvZG9MaXN0IC8+XG5cdFx0PEZvb3RlciAvPlx0XHRcblx0PC9kaXY+XG4pO1xuXG5jb25zdCB7IFByb3ZpZGVyIH0gPSBSZWFjdFJlZHV4O1xuLy8gRVM2ICB2aWEgYmFiZWw6IGltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuLy8gRVM1OiB2YXIgUHJvdmlkZXIgPSByZXF1aXJlKCdyZWFjdC1yZWR1eCcpLlByb3ZpZGVyO1xuXG5jb25zdCB7IGNyZWF0ZVN0b3JlIH0gPSBSZWR1eDtcblxuUmVhY3RET00ucmVuZGVyKFxuXHQ8UHJvdmlkZXIgc3RvcmU9e2NyZWF0ZVN0b3JlKHRvZG9BcHApfT5cblx0XHQ8VG9kb0FwcCAvPlxuXHQ8L1Byb3ZpZGVyPixcblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKVxuKTtcbiJdfQ==
